<!DOCTYPE html>
<html>
<head>
  <style>
    :root {
      --background-color: #2c2c2c;
      --text-color: #e0e0e0;
      --border-color: #444444;
      --section-hover: #3e3e3e;
      --property-background: #383838;
      --property-text: #cccccc;
      --grid-gap: 8px;
    }

    body {
      background-color: var(--background-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      font-size: 11px;
    }

    .plugin-container {
      padding: 0 12px;
      position: relative;
    }

    .section {
      margin: 0 -12px;
      border-bottom: 1px solid var(--border-color);
      display: block;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      cursor: pointer;
      user-select: none;
    }

    .section-header:hover {
      background-color: var(--section-hover);
    }

    .section-header h3 {
      font-size: 11px;
      margin: 0;
      font-weight: 500;
    }

    .section-arrow {
      width: 12px;
      height: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 8px;
      transform: rotate(-90deg);
    }

    .section-arrow.expanded {
      transform: rotate(0deg);
    }

    .section-content-wrapper {
      height: 0;
      overflow: hidden;
      transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .section-content {
      padding: 8px 12px;
      max-width: 300px; /* Or whatever maximum width makes sense for your layout */
    }

    /* Property Grid */
    .properties-grid {
      display: flex;
      flex-wrap: wrap;
      gap: 8px;
      max-width: 100%;
    }

    /* Property Blocks */
    .property-block {
      background-color: rgba(255, 255, 255, 0.06);
      border-radius: 4px;
      padding: 4px 8px;
      display: flex;
      align-items: center;
      height: 28px;
      min-width: fit-content;
      max-width: 100%;
      flex: 0 1 auto;
      position: relative;
      box-sizing: border-box;
      border: 1px solid transparent;
      transition: border-color 0.2s ease;
    }

    .property-block:hover {
      border-color: rgba(255, 255, 255, 0.1);
    }

    .property-block .property-value {
      color: var(--property-text);
      font-weight: 500;
      font-size: 11px;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: flex;
      align-items: center;
      flex: 1;
    }

    .property-label {
      color: #888888;
      font-size: 11px;
      white-space: nowrap;
      margin-right: 12px;
    }

    /* Property Block States */
    .property-block[data-state="default"] {
      background-color: rgba(255, 255, 255, 0.06);
      border-color: transparent;
    }

    .property-block[data-state="editing"] {
      border-color: #4C8BFF;
      background-color: var(--section-hover);
    }

    .property-block[data-state="modified"] {
      border-color: #4C8BFF;
    }

    .property-block[data-state="locked"] {
      opacity: 0.7;
      pointer-events: none;
    }

    /* Input styling for edit states */
    .property-block[data-state="editing"] input,
    .property-block[data-state="editing"] select {
      background: var(--section-hover);
      border: 1px solid var(--border-color);
      border-radius: 2px;
      color: var(--text-color);
      font-size: 11px;
      padding: 2px 4px;
      min-width: 40px;
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      height: 20px;
    }

    .property-block[data-state="editing"] input[type="number"] {
      width: 50px;
      text-align: right;
    }

    .property-block[data-state="editing"] select {
      min-width: 80px;
      height: 24px;
    }

    /* Remove all property-specific styles that will be handled by behaviors */
    .status-bar {
      display: none;
    }

    .layer-tree {
      display: none;
    }

    .raw-data {
      display: none;
    }

    .property-color {
      display: flex;
      align-items: center;
      gap: 4px;
      min-width: 0;
      flex: 1;
    }

    .property-color-preview {
      flex-shrink: 0;
      width: 12px;
      height: 12px;
      border-radius: 2px;
      border: 1px solid var(--border-color);
    }

    .property-color-value {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .property-opacity-value {
      flex-shrink: 0;
      color: var(--property-text);
      opacity: 0.8;
      margin-left: 4px;
      padding-left: 4px;
      border-left: 1px solid var(--border-color);
    }

    .property-stroke {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .property-stroke span {
      flex-shrink: 0;
      min-width: 16px;
      text-align: right;
    }

    .property-radius {
      display: flex;
      align-items: center;
    }

    .property-radius-value {
      min-width: 16px;
      text-align: right;
    }

    /* Ensure property blocks maintain their layout */
    .property-block {
      display: flex !important;
      justify-content: space-between !important;
      align-items: center !important;
      flex-direction: row !important;
    }

    .property-block .property-value {
      display: flex !important;
      flex-direction: row !important;
      align-items: center !important;
    }

    /* Reset any nested flex containers */
    .property-block .property-value > div {
      width: auto !important;
      flex: 1 !important;
    }

    /* Update the CSS for stroke weight */
    .property-stroke-weight {
      flex-shrink: 0;
      color: var(--property-text);
      opacity: 0.8;
      margin-left: 4px;
      padding-left: 4px;
      border-left: 1px solid var(--border-color);
    }

    /* Add styles for the selection title */
    .selection-title {
      padding: 12px;
      border-bottom: 1px solid var(--border-color);
      margin: 0 -12px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: fit-content;
    }

    .selection-name {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-color);
      margin: 0;
      padding: 0;
      line-height: 1.4;
    }

    .selection-type {
      font-size: 11px;
      color: #888888;
      margin: 4px 0 0 0;
      padding: 0;
      line-height: 1.2;
    }

    /* Add styles for the status indicator */
    .status-indicator {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: #4CAF50;
      opacity: 0.8;
    }

    .status-indicator.error {
      background-color: #f44336;
    }

    .status-indicator.warning {
      background-color: #ff9800;
    }

    /* Add styles for hidden sections */
    .section.hidden {
      display: none;
    }

    /* Add styles for numeric control */
    .numeric-control {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .numeric-control button {
      background: none;
      border: 1px solid var(--border-color);
      color: var(--text-color);
      width: 16px;
      height: 16px;
      border-radius: 2px;
      display: flex;
      align-items: center;
      justify-content: center;
      padding: 0;
      font-size: 10px;
      cursor: pointer;
    }

    .numeric-control button:hover {
      background-color: var(--section-hover);
    }

    .property-block .edit-button {
      display: none;
      background: none;
      border: none;
      color: var(--text-color);
      width: 16px;
      height: 16px;
      border-radius: 2px;
      margin-left: 4px;
      cursor: pointer;
      opacity: 0.7;
    }

    .property-block .edit-button:hover {
      opacity: 1;
      background-color: var(--section-hover);
    }

    .property-block .edit-button::before {
      content: "✎";
      font-size: 10px;
    }

    .property-block:not(.editing):hover .edit-button {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .property-block .reset-button {
      display: none;
      background: none;
      border: none;
      color: var(--text-color);
      width: 16px;
      height: 16px;
      border-radius: 2px;
      margin-left: 4px;
      cursor: pointer;
      opacity: 0.7;
    }

    .property-block .reset-button:hover {
      opacity: 1;
      background-color: var(--section-hover);
    }

    .property-block .reset-button::before {
      content: "↺";
      font-size: 10px;
    }

    .property-block.manually-edited .reset-button {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Remove spinner arrows from number inputs */
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    
    input[type=number] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Style numeric inputs to match the screenshot */
    .property-block.editing input[type=number],
    .property-block input[type=number] {
      width: auto;
      min-width: 30px;
      padding: 2px 4px;
      text-align: center;
      background-color: var(--background-color);
      border: 1px solid #4C8BFF;
      border-radius: 4px;
      color: var(--text-color);
      outline: none;
      box-shadow: 0 0 0 2px rgba(76, 139, 255, 0.2);
      font-size: 11px;
      font-weight: 500;
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
    }

    /* Specific styling for padding multi-inputs */
    .property-padding-value input[type=number] {
      margin-left: 4px;
    }

    /* Ensure padding inputs have spacing */
    .property-padding {
      display: flex;
      align-items: center;
      justify-content: space-between;
      width: 100%;
    }

    /* Specific styling for position multi-inputs */
    .property-position-value input[type=number] {
      width: fit-content; /* Try to fit content */
      min-width: 25px;
      max-width: 60px; /* Limit maximum expansion */
    }

    /* Consistent styling for all multi-input fields with content-hugging */
    .property-position-value input[type=number],
    .property-size-value input[type=number],
    .property-constraints-value input[type=number],
    .property-sizing-value input[type=number],
    .property-padding-value input[type=number] {
      min-width: unset;
      width: auto;
      font-size: 11px;
      font-weight: 500;
      height: 20px;
      line-height: 1;
      text-align: center;
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      padding: 0 2px;
      box-sizing: border-box;
    }

    /* Container styling updates */
    .property-position {
      display: flex;
      align-items: center;
      width: 100%;
      gap: 4px;
    }
    
    .property-position-value {
      flex: 0 0 auto; /* Don't grow, don't shrink, size based on content */
      min-width: auto;
    }
    
    /* Label style for X: and Y: */
    .property-position-value:first-child::before,
    .property-position-value:last-child::before {
      flex: 0 0 auto; /* Don't grow or shrink */
    }

    /* Remove duplicate pseudo-element definitions */
    .property-position-value:first-child::before {
      content: "X: ";
      color: #888888;
      font-size: 11px;
      font-weight: normal;
    }

    .property-position-value:last-child::before {
      content: "Y: ";
      color: #888888;
      font-size: 11px;
      font-weight: normal;
    }

    .property-size-value:first-child::before {
      content: "X: ";
      color: #888888;
      font-size: 11px;
      font-weight: normal;
    }

    .property-size-value:last-child::before {
      content: "Y: ";
      color: #888888;
      font-size: 11px;
      font-weight: normal;
    }

    .property-constraints-value:first-child::before {
      content: "H: ";
      color: #888888;
      font-size: 11px;
      font-weight: normal;
    }

    .property-constraints-value:last-child::before {
      content: "V: ";
      color: #888888;
      font-size: 11px;
      font-weight: normal;
    }

    .property-sizing-value:first-child::before {
      content: "H: ";
      color: #888888;
      font-size: 11px;
      font-weight: normal;
    }

    .property-sizing-value:last-child::before {
      content: "V: ";
      color: #888888;
      font-size: 11px;
      font-weight: normal;
    }

    .property-padding-value::before {
      content: attr(data-label);
      color: #888888;
      font-size: 11px;
      font-weight: normal;
    }

    /* Ensure consistent styling for value spans */
    .property-position-value span,
    .property-size-value span,
    .property-constraints-value span,
    .property-sizing-value span,
    .property-padding-value span {
      font-weight: 500;
      font-size: 11px;
      line-height: 1;
    }

  </style>
</head>
<body>
  <div class="plugin-container">
    <div class="status-indicator" title="Plugin initialized"></div>
    <div class="selection-title">
      <h2 class="selection-name">No Selection</h2>
      <p class="selection-type">Select an element to view properties</p>
      </div>

    <div class="section">
      <div class="section-header">
        <h3>Layout</h3>
        <div class="section-arrow">▼</div>
      </div>
      <div class="section-content-wrapper">
        <div class="section-content">
          <div class="properties-grid" id="layout-properties">
            <!-- Layout properties will be dynamically generated here -->
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-header">
        <h3>Position & Size</h3>
        <div class="section-arrow">▼</div>
        </div>
      <div class="section-content-wrapper">
        <div class="section-content">
          <div class="properties-grid" id="position-size-properties">
            <!-- Position & Size properties will be dynamically generated here -->
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-header">
        <h3>Styles</h3>
        <div class="section-arrow">▼</div>
      </div>
      <div class="section-content-wrapper">
        <div class="section-content">
          <div class="properties-grid" id="style-properties">
            <!-- Style properties will be dynamically generated here -->
          </div>
        </div>
        </div>
      </div>

    <div class="section">
      <div class="section-header">
        <h3>Text</h3>
        <div class="section-arrow">▼</div>
      </div>
      <div class="section-content-wrapper">
        <div class="section-content">
          <div class="properties-grid" id="text-properties">
            <!-- Text properties will be dynamically generated here -->
          </div>
        </div>
        </div>
      </div>

    <div class="section">
      <div class="section-header">
        <h3>Raw Data</h3>
        <div class="section-arrow">▼</div>
        </div>
      <div class="section-content-wrapper">
        <div class="section-content">
          <pre id="raw-data"></pre>
      </div>
    </div>
  </div>

    <div class="status-bar">
      <div class="status-text">Plugin Status: <span id="plugin-status">Initializing...</span></div>
    </div>
  </div>

  <!-- Load utility scripts -->
  <script>
    // PropertyBlock and Behavior classes - add before other code
    class PropertyBlock {
      constructor(nameOrElement, options = {}) {
        this.behaviors = [];
        this.options = options;
        
        if (typeof nameOrElement === 'string') {
          // Create new property block
          this.propertyName = nameOrElement;
          this.element = this.createBlockElement(nameOrElement, options);
        } else {
          // Use existing element
          this.element = nameOrElement;
          this.propertyName = this.element.dataset.property;
        }
      }
      
      createBlockElement(propertyName, options) {
        const block = document.createElement('div');
        block.className = 'property-block';
        block.dataset.property = propertyName;
        block.dataset.state = 'default';
        
        if (options.label) {
          const label = document.createElement('div');
          label.className = 'property-label';
          label.textContent = options.label;
          block.appendChild(label);
        }
        
        const valueContainer = document.createElement('div');
        valueContainer.className = 'property-value';
        block.appendChild(valueContainer);
        
        return block;
      }
      
      addBehavior(behavior) {
        this.behaviors.push(behavior);
        behavior.initialize(this);
        return this;
      }
      
      appendTo(containerId) {
        const container = document.getElementById(containerId);
        if (container) {
          container.appendChild(this.element);
        }
        return this;
      }
      
      setValue(value, options = {}) {
        const valueContainer = this.element.querySelector('.property-value');
        if (!valueContainer) return;
        
        this.value = value;
        
        // Store original value if isOriginal flag is set
        if (options.isOriginal) {
          valueContainer.dataset.originalContent = String(value);
        }
        
        // Notify behaviors
        this.behaviors.forEach(behavior => {
          if (behavior.onValueChange) {
            behavior.onValueChange(value, valueContainer);
          }
        });
        
        return this;
      }
      
      getValue() {
        const valueContainer = this.element.querySelector('.property-value');
        return this.value !== undefined ? this.value : valueContainer?.textContent?.trim();
      }
      
      setState(state) {
        this.element.dataset.state = state;
        
        // Notify behaviors
        this.behaviors.forEach(behavior => {
          if (behavior.onStateChange) {
            behavior.onStateChange(state);
          }
        });
        
        return this;
      }
      
      getState() {
        return this.element.dataset.state;
      }
    }
    
    /**
     * Base behavior class for property blocks
     */
    class Behavior {
      constructor() {
        this.block = null;
      }
      
      initialize(block) {
        this.block = block;
      }
      
      renderValue(value, container) {
        container.textContent = value;
      }
      
      onValueChange(value, container) {
        this.renderValue(value, container);
      }
      
      onStateChange(state) {
        // Handle state change
      }
    }
    
    /**
     * Base class for behaviors that handle editing
     */
    class EditBehavior extends Behavior {
      constructor(options = {}) {
        super();
        this.options = options;
        this.isEditing = false;
      }
      
      initialize(block) {
        super.initialize(block);
        
        // Add click handler to start editing
        this.block.element.addEventListener('click', (e) => {
          if (this.block.getState() !== 'locked') {
            this.startEditing();
          }
        });
      }
      
      startEditing() {
        if (this.isEditing) return;
        
        this.isEditing = true;
        this.block.setState('editing');
        this.renderEditableValue();
        
        // Add click outside handler to stop editing
        document.addEventListener('click', this.handleClickOutside = (e) => {
          if (!this.block.element.contains(e.target)) {
            this.stopEditing();
          }
        });
      }
      
      stopEditing() {
        if (!this.isEditing) return;
        
        this.isEditing = false;
        this.block.setState(this.block.element.classList.contains('manually-edited') ? 'modified' : 'default');
        
        // Remove click outside handler
        document.removeEventListener('click', this.handleClickOutside);
      }
      
      renderEditableValue() {
        // To be implemented by subclasses
      }
    }
    
    /**
     * Behavior for number inputs
     */
    class NumberInputBehavior extends EditBehavior {
      constructor(options = {}) {
        super(options);
        this.min = options.min !== undefined ? options.min : -Infinity;
        this.max = options.max !== undefined ? options.max : Infinity;
        this.step = options.step || 1;
        this.unit = options.unit || '';
      }
      
      renderValue(value, container) {
        // Clear existing content
        container.innerHTML = '';
        
        // Format value with unit if provided
        const formattedValue = `${value}${this.unit}`;
        container.textContent = formattedValue;
      }
      
      renderEditableValue() {
        const valueContainer = this.block.element.querySelector('.property-value');
        if (!valueContainer) return;
        
        // Clear existing content
        valueContainer.innerHTML = '';
        
        // Create input
        const input = document.createElement('input');
        input.type = 'number';
        input.min = this.min;
        input.max = this.max;
        input.step = this.step;
        
        // Remove unit for editing
        const currentValue = this.block.getValue();
        const numericValue = parseFloat(currentValue);
        input.value = isNaN(numericValue) ? 0 : numericValue;
        
        // Handle input
        input.addEventListener('input', () => {
          const newValue = parseFloat(input.value);
          if (!isNaN(newValue)) {
            // Use setValue to update the value with the unit
            this.block.setValue(newValue);
            this.block.element.classList.add('manually-edited');
          }
        });
        
        // Add to container and focus
        valueContainer.appendChild(input);
        input.focus();
        input.select();
      }
    }
    
    /**
     * Behavior for reset button
     */
    class ResetButtonBehavior extends Behavior {
      constructor() {
        super();
      }
      
      initialize(block) {
        super.initialize(block);
        
        // Find or create reset button
        let resetButton = block.element.querySelector('.reset-button');
        if (!resetButton) {
          resetButton = document.createElement('button');
          resetButton.className = 'reset-button';
          resetButton.title = 'Reset to original value';
          block.element.appendChild(resetButton);
        }
        
        // Add click handler
        resetButton.addEventListener('click', (e) => {
          e.stopPropagation();
          this.resetToOriginal();
        });
      }
      
      resetToOriginal() {
        const valueContainer = this.block.element.querySelector('.property-value');
        if (!valueContainer || !valueContainer.dataset.originalContent) return;
        
        // Reset value to original
        this.block.setValue(valueContainer.dataset.originalContent);
        this.block.element.classList.remove('manually-edited');
        this.block.setState('default');
      }
    }

    // Property interpretation utilities
    function interpretLayoutType(node) {
      if (!node) return "None";
      
      console.log('Checking layout type for node:', node);
      
      // Check for auto layout in the layout object
      if (node.layout?.mode) {
        console.log('Found layout mode:', node.layout.mode);
        return "Flex";
      }
      
      // Then check node type
      if (node.type === "FRAME") {
        console.log('Found FRAME type');
        return "Block";
      }
      if (node.type === "GROUP") {
        console.log('Found GROUP type');
        return "Flex";
      }
      
      return "None";
    }

    function interpretDirection(node) {
      if (!node) return "row";
      
      console.log('Checking direction for node:', node);
      
      // Check for layout mode in the layout object
      if (node.layout?.mode === "VERTICAL") {
        console.log('Found VERTICAL layout');
        return "column";
      }
      if (node.layout?.mode === "HORIZONTAL") {
        console.log('Found HORIZONTAL layout');
        return "row";
      }
      
      return "row";
    }

    function interpretAlignItems(node) {
      if (!node) return "flex-start";
      
      console.log('Checking alignItems for node:', node);
      
      // Check for counterAxisAlignItems in the layout object
      if (node.layout?.counterAxis?.alignItems) {
        console.log('Found counterAxisAlignItems:', node.layout.counterAxis.alignItems);
        switch (node.layout.counterAxis.alignItems) {
          case "MIN":
            return "flex-start";
          case "MAX":
            return "flex-end";
          case "CENTER":
            return "center";
          case "SPACE_BETWEEN":
            return "space-between";
        }
      }
      
      return "flex-start";
    }

    function interpretJustifyContent(node) {
      if (!node) return "flex-start";
      
      console.log('Checking justifyContent for node:', node);
      
      // Check for primaryAxisAlignItems in the layout object
      if (node.layout?.primaryAxis?.alignItems) {
        console.log('Found primaryAxisAlignItems:', node.layout.primaryAxis.alignItems);
        switch (node.layout.primaryAxis.alignItems) {
          case "MIN":
            return "flex-start";
          case "MAX":
            return "flex-end";
          case "CENTER":
            return "center";
          case "SPACE_BETWEEN":
            return "space-between";
          case "SPACE_AROUND":
            return "space-around";
        }
      }
      
      return "flex-start";
    }

    function interpretPadding(node) {
      if (!node) return { top: 0, right: 0, bottom: 0, left: 0 };
      
      console.log('Checking padding for node:', node);
      
      // Check for padding in the layout object
      if (node.layout?.padding) {
        const padding = {
          top: node.layout.padding.top || 0,
          right: node.layout.padding.right || 0,
          bottom: node.layout.padding.bottom || 0,
          left: node.layout.padding.left || 0
        };
        console.log('Found padding in layout object:', padding);
        return padding;
      }
      
      return { top: 0, right: 0, bottom: 0, left: 0 };
    }

    function interpretGap(node) {
      if (!node) return 0;
      
      console.log('Checking gap for node:', node);
      
      // Check for itemSpacing in the layout object
      if (node.layout?.spacing?.items) {
        console.log('Found itemSpacing in layout object:', node.layout.spacing.items);
        return node.layout.spacing.items;
      }
      
      return 0;
    }

    function interpretLayoutProperties(node) {
      if (!node) return null;
      
      console.log('Interpreting layout properties for node:', node);
      console.log('Node layout object:', node.layout);
      console.log('Node autoLayout:', node.layout?.autoLayout);
      console.log('Node parent layout:', node.layout?.parent);
      console.log('Node parent autoLayout:', node.layout?.parent?.autoLayout);
      
      // Check if the node has layout properties
      const hasLayout = node.layout;
      console.log('Has layout:', hasLayout);
      
      const interpreted = {
        type: interpretLayoutType(node),
        direction: interpretDirection(node),
        alignItems: interpretAlignItems(node),
        justifyContent: interpretJustifyContent(node),
        gap: interpretGap(node),
        padding: interpretPadding(node)
      };
      
      console.log('Interpreted properties:', interpreted);
      return interpreted;
    }

    function interpretBlendMode(blendMode) {
      if (!blendMode) return 'Normal';
      
      console.log('Interpreting blend mode:', blendMode);
      
      switch (blendMode) {
        case 'PASS_THROUGH':
          return 'Pass Through';
        case 'NORMAL':
          return 'Normal';
        case 'DARKEN':
          return 'Darken';
        case 'MULTIPLY':
          return 'Multiply';
        case 'LINEAR_BURN':
          return 'Linear Burn';
        case 'COLOR_BURN':
          return 'Color Burn';
        case 'LIGHTEN':
          return 'Lighten';
        case 'SCREEN':
          return 'Screen';
        case 'LINEAR_DODGE':
          return 'Linear Dodge';
        case 'COLOR_DODGE':
          return 'Color Dodge';
        case 'OVERLAY':
          return 'Overlay';
        case 'SOFT_LIGHT':
          return 'Soft Light';
        case 'HARD_LIGHT':
          return 'Hard Light';
        case 'DIFFERENCE':
          return 'Difference';
        case 'EXCLUSION':
          return 'Exclusion';
        case 'HUE':
          return 'Hue';
        case 'SATURATION':
          return 'Saturation';
        case 'COLOR':
          return 'Color';
        case 'LUMINOSITY':
          return 'Luminosity';
        default:
          return blendMode;
      }
    }

    // Add this function with the other utility functions
    function rgbToHex(r, g, b) {
      const toHex = (n) => {
        const hex = Math.round(n * 255).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
    }

    const pluginStatus = document.getElementById('plugin-status');
    const rawDataDisplay = document.getElementById('raw-data');
    let currentSelection = null;

    function formatValue(value) {
      if (value === null) return 'null';
      if (value === undefined) return 'undefined';
      if (typeof value === 'object') {
        return JSON.stringify(value, null, 2);
      }
      return String(value);
    }

    function renderPropertyGroup(container, title, properties) {
      const group = document.createElement('div');
      group.className = 'property-group';
      
      const titleEl = document.createElement('div');
      titleEl.className = 'property-group-title';
      titleEl.textContent = title;
      group.appendChild(titleEl);

      Object.entries(properties).forEach(([key, value]) => {
        const item = document.createElement('div');
        item.className = 'property-item';
        
        const name = document.createElement('span');
        name.className = 'property-name';
        name.textContent = key;
        
        const val = document.createElement('span');
        val.className = 'property-value';
        val.textContent = formatValue(value);
        
        item.appendChild(name);
        item.appendChild(val);
        group.appendChild(item);
      });

      container.appendChild(group);
    }

    function renderLayerTree(items) {
      const container = document.querySelector('.layer-tree');
      if (!container) return;
      
      container.innerHTML = ''; // Clear existing items
      
      items.forEach(item => {
        const treeItem = document.createElement('div');
        treeItem.className = 'tree-item';
        treeItem.dataset.id = item.id;
        treeItem.textContent = `${item.name} (${item.type})`;
        treeItem.addEventListener('click', () => selectLayer(item.id));
        container.appendChild(treeItem);
      });
    }

    function selectLayer(id) {
      // Remove selection from all items
      document.querySelectorAll('.tree-item').forEach(item => {
        item.classList.remove('selected');
      });

      // Add selection to clicked item
      const selectedItem = document.querySelector(`.tree-item[data-id="${id}"]`);
      if (selectedItem) {
        selectedItem.classList.add('selected');
      }

      // Request raw node data from the plugin
      parent.postMessage({
        pluginMessage: {
          type: 'get-raw-node-data',
          id: id
        }
      }, '*');
    }
    
    function displayRawData(data) {
      if (!data) return;
      
      rawDataDisplay.innerHTML = '';

      // Group and display properties
      if (data.id && data.name && data.type) {
        renderPropertyGroup(rawDataDisplay, 'Basic Info', {
          id: data.id,
          name: data.name,
          type: data.type,
          visible: data.visible
        });
      }

      if (data.position) {
        renderPropertyGroup(rawDataDisplay, 'Position', data.position);
      }

      if (data.size) {
        renderPropertyGroup(rawDataDisplay, 'Size', data.size);
      }

      if (data.transform) {
        renderPropertyGroup(rawDataDisplay, 'Transform', data.transform);
      }

      if (data.layout) {
        renderPropertyGroup(rawDataDisplay, 'Layout', data.layout);
      }

      if (data.visual) {
        renderPropertyGroup(rawDataDisplay, 'Visual', data.visual);
      }

      // Type-specific properties
      if (data.text) {
        renderPropertyGroup(rawDataDisplay, 'Text Properties', data.text);
      }

      if (data.component) {
        renderPropertyGroup(rawDataDisplay, 'Component Properties', data.component);
      }

      if (data.section) {
        renderPropertyGroup(rawDataDisplay, 'Section Properties', data.section);
      }

      if (data.group) {
        renderPropertyGroup(rawDataDisplay, 'Group Properties', data.group);
      }

      if (data.vector) {
        renderPropertyGroup(rawDataDisplay, 'Vector Properties', data.vector);
      }

      // Debug all available properties
      console.log('=== ELEMENT PROPERTIES ANALYSIS ===');
      console.log('Element type:', data.type);
      console.log('All available properties:', Object.keys(data));
      
      // Text specific properties
      if (data.type === 'TEXT') {
        console.log('=== TEXT PROPERTIES ===');
        console.log('Text object:', data.text);
        if (data.text) {
          console.log('Text style:', data.text.style);
          console.log('Font family:', data.text.fontFamily);
          console.log('Font size:', data.text.fontSize);
          console.log('Text color:', data.text.fills);
          console.log('Text alignment:', data.text.textAlign);
          console.log('Line height:', data.text.lineHeight);
          console.log('Letter spacing:', data.text.letterSpacing);
        }
      }
      
      // Shape specific properties
      if (data.type === 'RECTANGLE' || data.type === 'ELLIPSE' || data.type === 'POLYGON' || data.type === 'STAR') {
        console.log('=== SHAPE PROPERTIES ===');
        console.log('Visual object:', data.visual);
        if (data.visual) {
          console.log('Fills:', data.visual.fills);
          console.log('Strokes:', data.visual.strokes);
          console.log('Stroke weight:', data.visual.strokeWeight);
          console.log('Corner radius:', data.visual.cornerRadius);
        }
      }
      
      // Frame specific properties
      if (data.type === 'FRAME' || data.type === 'GROUP') {
        console.log('=== FRAME PROPERTIES ===');
        console.log('Visual object:', data.visual);
        if (data.visual) {
          console.log('Backgrounds:', data.visual.backgrounds);
          console.log('Effects:', data.visual.effects);
          console.log('Layout mode:', data.layout?.mode);
        }
      }
      
      // Component specific properties
      if (data.type === 'COMPONENT' || data.type === 'INSTANCE') {
        console.log('=== COMPONENT PROPERTIES ===');
        console.log('Component object:', data.component);
        if (data.component) {
          console.log('Component properties:', data.component.properties);
          console.log('Variant properties:', data.component.variantProperties);
        }
      }
      
      // Common properties
      console.log('=== COMMON PROPERTIES ===');
      console.log('Visual object:', data.visual);
      if (data.visual) {
        console.log('Opacity:', data.visual.opacity);
        console.log('Blend mode:', data.visual.blendMode);
        console.log('Effects:', data.visual.effects);
      }
      console.log('Constraints:', data.layout?.constraints);
      console.log('Layout constraints:', data.layout?.layoutConstraints);
      console.log('========================');
    }

    function updateSectionVisibility(data) {
      if (!data) return;

      // Find all sections
      const sections = document.querySelectorAll('.section');
      
      // Show/hide sections based on element type
      sections.forEach(section => {
        const header = section.querySelector('h3');
        if (!header) return;

        // Hide Raw Data section
        if (header.textContent === 'Raw Data') {
          section.classList.add('hidden');
        } 
        // Hide Text section for non-text elements
        else if (header.textContent === 'Text' && data.type !== 'TEXT') {
          section.classList.add('hidden');
        }
        // Show all other sections
        else {
          section.classList.remove('hidden');
          if (section.style.display) {
            section.style.removeProperty('display');
          }
        }
      });

      console.log('=== SECTION VISIBILITY UPDATE ===');
      console.log('Element type:', data.type);
      sections.forEach(section => {
        const header = section.querySelector('h3');
        if (header) {
          console.log(`${header.textContent}: ${!section.classList.contains('hidden')}`);
        }
      });
    }

    function isActuallyInAutoLayoutDespiteBeingAbsolute(data) {
      if (data.type !== "TEXT") return false;

      const layoutMode = data.layout?.parent?.layoutMode;
      const positioning = data.layout?.positioning;
      const constraints = data.layout?.constraints || {};
      const hasNeutralConstraints = (
        constraints.horizontal === "MIN" &&
        constraints.vertical === "MIN"
      );

      // Check if node is being flagged as absolute
      const isMarkedAbsolute = positioning === "ABSOLUTE";

      // Check if parent is auto layout
      const isInsideAutoLayout = layoutMode === "HORIZONTAL" || layoutMode === "VERTICAL";

      // Fix only if:
      // 1. It's marked as ABSOLUTE
      // 2. It's inside an auto layout
      // 3. It has no meaningful constraints (so likely in flow visually)
      if (isMarkedAbsolute && isInsideAutoLayout && hasNeutralConstraints) {
        return true; // treat as relative (override the false positive)
      }

      // If the text element has AUTO positioning, it's in auto layout
      if (positioning === "AUTO") {
        return true;
      }

      return false;
    }

    function updateLayoutProperties(data) {
      if (!data) {
        console.log('No data provided to updateLayoutProperties');
        return;
      }
      
      console.log('=== DEBUGGING AUTO LAYOUT DETECTION ===');
      console.log('Raw node data:', data);
      console.log('Node layout:', data.layout);
      console.log('Node autoLayout:', data.layout?.autoLayout);
      console.log('Node parent layout:', data.layout?.parent);
      console.log('Node parent layoutMode:', data.layout?.parent?.layoutMode);
      console.log('Node positioning:', data.layout?.positioning);
      
      // Add detailed debugging for text nodes
      if (data.type === "TEXT") {
        console.log('>>> OVERRIDE CHECK for TEXT NODE <<<');
        console.log('Type:', data.type);
        console.log('Positioning:', data.layout?.positioning);
        console.log('Parent layoutMode:', data.layout?.parent?.layoutMode);
        console.log('Constraints:', data.layout?.constraints);
        console.log('Override applied:', isActuallyInAutoLayoutDespiteBeingAbsolute(data));
      }
      
      // Update UI elements
      try {
        const isAutoLayoutContainer = data.layout?.autoLayout?.mode !== undefined;
        const isActuallyInAutoLayout = isActuallyInAutoLayoutDespiteBeingAbsolute(data);
        const isInAutoLayout = 
          data.layout?.type === 'AUTO' || 
          data.layout?.parent?.type === 'AUTO' ||
          data.layout?.parent?.layoutMode === "HORIZONTAL" ||
          data.layout?.parent?.layoutMode === "VERTICAL" ||
          isActuallyInAutoLayout;
        const ignoresAutoLayout = data.layout?.isIgnoringAutoLayout === true && !isActuallyInAutoLayout;
        const positioning = data.layout?.positioning;
        
        console.log('=== DETECTION RESULTS ===');
        console.log('isAutoLayoutContainer:', isAutoLayoutContainer);
        console.log('isActuallyInAutoLayout:', isActuallyInAutoLayout);
        console.log('isInAutoLayout:', isInAutoLayout);
        console.log('ignoresAutoLayout:', ignoresAutoLayout);
        console.log('positioning:', positioning);
        console.log('========================');

        // Find property blocks by property name
        const findPropertyBlock = (name) => {
          const element = document.querySelector(`[data-property="${name}"]`);
          if (!element) return null;
          return new PropertyBlock(element);
        };

        // Update positioning type
        const positioningBlock = findPropertyBlock('positioning');
        if (positioningBlock) {
          const positioningType = (isInAutoLayout && !ignoresAutoLayout) ? "Relative" : "Absolute";
          positioningBlock.setValue(positioningType, { isOriginal: true });
          console.log('Positioning type:', positioningType);
        }

        // Update overflow
        const overflowBlock = findPropertyBlock('overflow');
        if (overflowBlock) {
          const overflowValue = data.clipsContent ? "hidden" : "visible";
          overflowBlock.setValue(overflowValue, { isOriginal: true });
          console.log('Overflow:', overflowValue);
        }

        // Update z-index
        const zIndexBlock = findPropertyBlock('z-index');
        if (zIndexBlock) {
          // Default to 0 unless specified
          const zIndexValue = data.zIndex || 0;
          zIndexBlock.setValue(zIndexValue, { isOriginal: true });
          console.log('Z-index:', zIndexValue);
        }

        // Update editability based on positioning
        const positionBlock = findPropertyBlock('position');
        const constraintsBlock = findPropertyBlock('constraints');
        
        if (isInAutoLayout && !ignoresAutoLayout) {
          if (positionBlock) positionBlock.setState('locked');
          if (constraintsBlock) constraintsBlock.setState('locked');
        } else {
          if (positionBlock) positionBlock.setState('default');
          if (constraintsBlock) constraintsBlock.setState('default');
        }

        // Update layout properties
        const typeBlock = findPropertyBlock('type');
        if (typeBlock) {
          typeBlock.setValue(isAutoLayoutContainer ? "Flex" : "Block", { isOriginal: true });
          console.log('Layout type:', isAutoLayoutContainer ? "Flex" : "Block");
        }

        const directionBlock = findPropertyBlock('direction');
        if (directionBlock) {
          directionBlock.setValue(data.layout?.autoLayout?.mode === "VERTICAL" ? "column" : "row", { isOriginal: true });
          console.log('Direction:', data.layout?.autoLayout?.mode === "VERTICAL" ? "column" : "row");
        }

        const alignBlock = findPropertyBlock('align');
        if (alignBlock) {
          const align = data.layout?.autoLayout?.counterAxis?.alignItems || "MIN";
          const alignValue = 
            (align === "MIN" ? "flex-start" : 
             align === "MAX" ? "flex-end" : 
             align === "CENTER" ? "center" : "flex-start");
          alignBlock.setValue(alignValue, { isOriginal: true });
          console.log('Align:', alignValue);
        }

        const justifyBlock = findPropertyBlock('justify');
        if (justifyBlock) {
          const justify = data.layout?.autoLayout?.primaryAxis?.alignItems || "MIN";
          const justifyValue = 
            (justify === "MIN" ? "flex-start" : 
             justify === "MAX" ? "flex-end" : 
             justify === "CENTER" ? "center" : 
             justify === "SPACE_BETWEEN" ? "space-between" : "flex-start");
          justifyBlock.setValue(justifyValue, { isOriginal: true });
          console.log('Justify:', justifyValue);
        }

        const gapBlock = findPropertyBlock('gap');
        if (gapBlock) {
          gapBlock.setValue(data.layout?.autoLayout?.spacing?.items || 0, { isOriginal: true });
          console.log('Gap:', data.layout?.autoLayout?.spacing?.items || 0);
        }

        // Additional property blocks will be updated as they are implemented

      } catch (error) {
        console.error('Error updating layout properties:', error);
      }
    }

    function updateTextProperties(data) {
      if (!data) return;

      // Get all text property elements
      const fontSizeEl = document.querySelector('.property-font-size-value');
      const colorEl = document.querySelector('[data-property="color"] .property-value');
      const alignmentEl = document.querySelector('[data-property="alignment"] .property-value');
      const lineHeightEl = document.querySelector('[data-property="line-height"] .property-value');
      const letterSpacingEl = document.querySelector('[data-property="letter-spacing"] .property-value');

      // Update text properties if it's a text layer
      if (data.type === 'TEXT') {
        console.log('=== DEBUGGING TEXT PROPERTIES ===');
        console.log('Text object:', data.text);
        console.log('Text style:', data.text?.style);
        console.log('Line height:', data.text?.style?.spacing?.line);
        console.log('========================');

        // Update font size
        if (fontSizeEl) {
          fontSizeEl.textContent = data.text?.style?.fontSize || 0;
        }

        // Update text color
        if (colorEl) {
          const colorPreview = colorEl.querySelector('.property-color-preview');
          const colorValue = colorEl.querySelector('.property-color-value');
          if (data.visual?.fills && data.visual.fills.length > 0) {
            const fill = data.visual.fills[0];
            if (fill.type === 'SOLID') {
              const color = fill.color;
              const opacity = fill.opacity || 1;
              colorPreview.style.backgroundColor = `rgba(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)}, ${opacity})`;
              colorValue.textContent = rgbToHex(color.r, color.g, color.b);
            } else {
              colorPreview.style.backgroundColor = 'transparent';
              colorValue.textContent = 'None';
            }
          } else {
            colorPreview.style.backgroundColor = 'transparent';
            colorValue.textContent = 'None';
          }
        }

        // Update text alignment
        if (alignmentEl) {
          const alignment = data.text?.style?.alignment?.horizontal || 'LEFT';
          alignmentEl.textContent = alignment.charAt(0) + alignment.slice(1).toLowerCase();
        }

        // Update line height
        if (lineHeightEl) {
          const lineHeight = data.text?.style?.spacing?.line;
          if (lineHeight && lineHeight.value !== undefined) {
            lineHeightEl.textContent = lineHeight.value;
          } else {
            lineHeightEl.textContent = 'Auto';
          }
        }

        // Update letter spacing
        if (letterSpacingEl) {
          const letterSpacing = data.text?.style?.spacing?.letter;
          if (letterSpacing && letterSpacing.value !== undefined) {
            if (letterSpacing.unit === 'PERCENT') {
              letterSpacingEl.textContent = `${letterSpacing.value}%`;
            } else {
              letterSpacingEl.textContent = letterSpacing.value;
            }
          } else {
            letterSpacingEl.textContent = '0';
          }
        }
      } else {
        // Clear all text properties for non-text layers
        if (fontSizeEl) fontSizeEl.textContent = '0';
        if (colorEl) {
          const colorPreview = colorEl.querySelector('.property-color-preview');
          const colorValue = colorEl.querySelector('.property-color-value');
          colorPreview.style.backgroundColor = 'transparent';
          colorValue.textContent = 'None';
        }
        if (alignmentEl) alignmentEl.textContent = 'Left';
        if (lineHeightEl) lineHeightEl.textContent = 'Auto';
        if (letterSpacingEl) letterSpacingEl.textContent = '0';
      }
    }

    function updateVisualProperties(data) {
      if (!data) {
        console.log('No data provided to updateVisualProperties');
        return;
      }

      console.log('=== DEBUGGING VISUAL PROPERTIES ===');
      console.log('Element type:', data.type);
      console.log('Raw visual data:', data.visual);
      console.log('Fills:', data.visual?.fills);
      console.log('Strokes:', data.visual?.strokes);
      console.log('Corner radius:', data.visual?.cornerRadius);
      console.log('Opacity:', data.visual?.opacity);
      console.log('Blend mode:', data.visual?.blendMode);
      console.log('Effects:', data.visual?.effects);
      console.log('========================');

      // Update visual properties based on element type
      const fillEl = document.querySelector('[data-property="fill"] .property-value');
      const strokeEl = document.querySelector('[data-property="stroke"] .property-value');
      const radiusEl = document.querySelector('[data-property="radius"] .property-value');
      const opacityEl = document.querySelector('[data-property="opacity"] .property-value');
      const blendEl = document.querySelector('[data-property="blend"] .property-value');
      const shadowEl = document.querySelector('[data-property="shadow"] .property-value');

      // Show/hide properties based on element type
      const blocks = {
        fill: document.querySelector('[data-property="fill"]'),
        stroke: document.querySelector('[data-property="stroke"]'),
        radius: document.querySelector('[data-property="radius"]'),
        opacity: document.querySelector('[data-property="opacity"]'),
        blend: document.querySelector('[data-property="blend"]'),
        shadow: document.querySelector('[data-property="shadow"]')
      };

      // Log which properties should be visible
      console.log('=== PROPERTY VISIBILITY ===');
      console.log('Element type:', data.type);
      console.log('Fill visible:', ['FRAME', 'RECTANGLE', 'ELLIPSE', 'POLYGON', 'STAR', 'TEXT'].includes(data.type));
      console.log('Stroke visible:', ['FRAME', 'RECTANGLE', 'ELLIPSE', 'POLYGON', 'STAR'].includes(data.type));
      console.log('Radius visible:', ['FRAME', 'RECTANGLE'].includes(data.type));
      console.log('========================');

      // Show/hide properties based on element type
      if (blocks.fill) {
        blocks.fill.style.display = ['FRAME', 'RECTANGLE', 'ELLIPSE', 'POLYGON', 'STAR', 'TEXT'].includes(data.type) ? 'block' : 'none';
      }
      if (blocks.stroke) {
        blocks.stroke.style.display = ['FRAME', 'RECTANGLE', 'ELLIPSE', 'POLYGON', 'STAR'].includes(data.type) ? 'block' : 'none';
      }
      if (blocks.radius) {
        blocks.radius.style.display = ['FRAME', 'RECTANGLE'].includes(data.type) ? 'block' : 'none';
      }
      if (blocks.opacity) {
        blocks.opacity.style.display = 'block'; // Always show opacity
      }
      if (blocks.blend) {
        blocks.blend.style.display = 'block'; // Always show blend mode
      }
      if (blocks.shadow) {
        blocks.shadow.style.display = ['FRAME', 'RECTANGLE', 'ELLIPSE', 'POLYGON', 'STAR', 'TEXT'].includes(data.type) ? 'block' : 'none';
      }

      // Update fill and opacity
      if (fillEl && data.visual?.fills && data.visual.fills.length > 0) {
        const fill = data.visual.fills[0];
        console.log('Processing fill:', fill);
        if (fill.type === 'SOLID') {
          const color = fill.color;
          const opacity = fill.opacity || 1;
          const colorPreview = fillEl.querySelector('.property-color-preview');
          const colorValue = fillEl.querySelector('.property-color-value');
          const opacityValue = fillEl.querySelector('.property-opacity-value');
          if (colorPreview && colorValue && opacityValue) {
            colorPreview.style.backgroundColor = `rgba(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)}, ${opacity})`;
            colorValue.textContent = rgbToHex(color.r, color.g, color.b);
            opacityValue.textContent = `${Math.round(opacity * 100)}%`;
            console.log('Updated fill color:', colorValue.textContent);
            console.log('Updated opacity:', opacityValue.textContent);
      } else {
            console.log('Color preview, value, or opacity elements not found');
          }
        } else {
          const colorPreview = fillEl?.querySelector('.property-color-preview');
          const colorValue = fillEl?.querySelector('.property-color-value');
          const opacityValue = fillEl?.querySelector('.property-opacity-value');
          if (colorPreview && colorValue && opacityValue) {
            colorPreview.style.backgroundColor = 'transparent';
            colorValue.textContent = 'None';
            opacityValue.textContent = '100%';
          }
          console.log('Non-solid fill type:', fill.type);
        }
      } else {
        const colorPreview = fillEl?.querySelector('.property-color-preview');
        const colorValue = fillEl?.querySelector('.property-color-value');
        const opacityValue = fillEl?.querySelector('.property-opacity-value');
        if (colorPreview && colorValue && opacityValue) {
          colorPreview.style.backgroundColor = 'transparent';
          colorValue.textContent = 'None';
          opacityValue.textContent = '100%';
        }
        console.log('No fills found or fill element not found');
      }

      // Update stroke
      if (strokeEl && data.visual?.strokes && data.visual.strokes.length > 0) {
        const stroke = data.visual.strokes[0];
        console.log('Processing stroke:', stroke);
        const colorPreview = strokeEl.querySelector('.property-color-preview');
        const colorValue = strokeEl.querySelector('.property-color-value');
        const strokeWeight = strokeEl.querySelector('.property-stroke-weight');
        
        if (stroke.type === 'SOLID' && colorPreview && colorValue && strokeWeight) {
          const color = stroke.color;
          const opacity = stroke.opacity || 1;
          const weight = data.visual.strokeWeight || 0;
          colorPreview.style.backgroundColor = `rgba(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)}, ${opacity})`;
          colorValue.textContent = rgbToHex(color.r, color.g, color.b);
          strokeWeight.textContent = weight;
          console.log('Updated stroke color:', colorValue.textContent);
          console.log('Updated stroke weight:', strokeWeight.textContent);
        } else {
          if (colorPreview) colorPreview.style.backgroundColor = 'transparent';
          if (colorValue) colorValue.textContent = 'None';
          if (strokeWeight) strokeWeight.textContent = '0';
          console.log('Non-solid stroke type:', stroke.type);
        }
      } else {
        const colorPreview = strokeEl?.querySelector('.property-color-preview');
        const colorValue = strokeEl?.querySelector('.property-color-value');
        const strokeWeight = strokeEl?.querySelector('.property-stroke-weight');
        if (colorPreview) colorPreview.style.backgroundColor = 'transparent';
        if (colorValue) colorValue.textContent = 'None';
        if (strokeWeight) strokeWeight.textContent = '0';
        console.log('No strokes found or stroke element not found');
      }

      // Update radius
      if (radiusEl) {
        const radiusValue = radiusEl.querySelector('.property-radius-value');
        if (radiusValue) {
          radiusValue.textContent = data.visual?.cornerRadius || 0;
          console.log('Updated corner radius:', radiusValue.textContent);
        }
      } else {
        console.log('Radius element not found');
      }

      // Update opacity
      if (opacityEl) {
        const opacity = Math.round((data.visual?.opacity || 1) * 100);
        opacityEl.textContent = `${opacity}%`;
        console.log('Updated opacity:', opacityEl.textContent);
      } else {
        console.log('Opacity element not found');
      }

      // Update blend mode
      if (blendEl) {
        const blendMode = data.visual?.blendMode || 'NORMAL';
        blendEl.textContent = interpretBlendMode(blendMode);
        console.log('Updated blend mode:', blendEl.textContent);
      } else {
        console.log('Blend mode element not found');
      }

      // Update shadow
      if (shadowEl) {
        if (data.visual?.effects && data.visual.effects.length > 0) {
          const shadow = data.visual.effects.find(effect => effect.type === 'DROP_SHADOW');
          shadowEl.textContent = shadow ? 'Enabled' : 'None';
          console.log('Updated shadow:', shadowEl.textContent);
        } else {
          shadowEl.textContent = 'None';
          console.log('No shadow effects found');
        }
      } else {
        console.log('Shadow element not found');
      }
    }

    // Update the window.onmessage handler
    window.onmessage = async (event) => {
      // Validate the message
      const msg = event.data.pluginMessage;
      if (!msg || !msg.type) {
        console.warn('Invalid message received:', event.data);
        return;
      }
      
      console.log('Message received:', msg.type);
      
      // Handle different message types
      switch (msg.type) {
        case 'selection-change':
        case 'selection':
          handleSelectionChange(msg.data);
          break;
          
        case 'raw-node-data':
          handleRawNodeData(msg.data);
          break;
          
        case 'plugin-status':
          updatePluginStatus(msg.message || 'Unknown status');
          break;
          
        case 'init':
          // Nothing special needed here since we initialize on load
          console.log('Plugin initialized');
          break;
          
        default:
          console.warn('Unknown message type:', msg.type);
      }
    };
    
    // Helper functions for message handling
    function handleSelectionChange(data) {
      if (!data) {
        console.warn('Selection data is empty');
        return;
      }
      
      // Update selection name and type display
      updateSelectionInfo(data);
      
      // Store current selection
      currentSelection = data;
      
      // Update property displays
      updateLayoutProperties(data);
      updateTextProperties(data);
      updateVisualProperties(data);
      
      // Show raw data for debugging
      updateRawDataDisplay(data);
    }
    
    function handleRawNodeData(data) {
      if (!data) {
        console.warn('Raw node data is empty');
        return;
      }
      
      // Update selection title
      updateSelectionInfo(data);
      
      // Update UI based on node data
      updateSectionVisibility(data);
      updateLayoutProperties(data);
      updateTextProperties(data);
      updateVisualProperties(data);
    }
    
    function updateSelectionInfo(data) {
      const nameEl = document.querySelector('.selection-name');
      const typeEl = document.querySelector('.selection-type');
      
      if (nameEl && data) {
        nameEl.textContent = data.name || 'Unnamed';
      }
      
      if (typeEl && data) {
        const typeText = data.type 
          ? data.type.charAt(0) + data.type.slice(1).toLowerCase() 
          : 'Unknown';
        typeEl.textContent = typeText;
      }
    }
    
    function updateRawDataDisplay(data) {
      const rawDataEl = document.getElementById('raw-data');
      if (rawDataEl && data) {
        rawDataEl.textContent = JSON.stringify(data, null, 2);
      }
    }
    
    function updatePluginStatus(message) {
      const statusEl = document.getElementById('plugin-status');
      if (statusEl) {
        statusEl.textContent = message;
      }
    }

    // Notify plugin that UI is ready
    parent.postMessage({ pluginMessage: { type: 'ready' } }, '*');

    function moveToDefinedProperties(propertyBlock) {
      const section = propertyBlock.closest('.section');
      const mainGrid = section.querySelector('.properties-grid');
      propertyBlock.classList.remove('undefined');
      mainGrid.appendChild(propertyBlock);
    }

    function moveToUndefinedProperties(propertyBlock) {
      const section = propertyBlock.closest('.section');
      const undefinedGrid = section.querySelector('.undefined-properties .properties-grid');
      propertyBlock.classList.add('undefined');
      undefinedGrid.appendChild(propertyBlock);
    }

    function initPropertyBlocks() {
      console.log('Initializing property blocks with new component system');
      
      // Clear existing property containers
      document.querySelectorAll('.properties-grid').forEach(grid => {
        grid.innerHTML = '';
      });
      
      // Layout section properties
      const layoutProperties = document.getElementById('layout-properties');
      const positionSizeProperties = document.getElementById('position-size-properties');
      const styleProperties = document.getElementById('style-properties');
      const textProperties = document.getElementById('text-properties');
      
      if (!layoutProperties || !positionSizeProperties || !styleProperties || !textProperties) {
        console.error('Could not find property containers!');
        console.log('layout-properties:', layoutProperties);
        console.log('position-size-properties:', positionSizeProperties);
        console.log('style-properties:', styleProperties);
        console.log('text-properties:', textProperties);
        return;
      }
      
      console.log('Found property containers, creating blocks...');
      
      // Layout section properties
      createPropertyBlock('dropdown', 'type', {
        label: 'Type',
        options: ['Block', 'Flex']
      }).appendTo('layout-properties');
      
      createPropertyBlock('dropdown', 'direction', {
        label: 'Direction',
        options: ['row', 'column']
      }).appendTo('layout-properties');
      
      createPropertyBlock('dropdown', 'align', {
        label: 'Align',
        options: ['flex-start', 'center', 'flex-end', 'space-between']
      }).appendTo('layout-properties');
      
      createPropertyBlock('dropdown', 'justify', {
        label: 'Justify',
        options: ['flex-start', 'center', 'flex-end', 'space-between', 'space-around']
      }).appendTo('layout-properties');
      
      createPropertyBlock('number', 'gap', {
        label: 'Gap',
        min: 0,
        max: 1000
      }).appendTo('layout-properties');
      
      createPropertyBlock('dropdown', 'overflow', {
        label: 'Overflow',
        options: ['visible', 'hidden']
      }).appendTo('layout-properties');
      
      // Position & Size properties
      createPropertyBlock('number', 'z-index', {
        label: 'Z-Index',
        min: -999,
        max: 999
      }).appendTo('position-size-properties');
      
      createPropertyBlock('number', 'rotation', {
        label: 'Rotation',
        min: 0,
        max: 360,
        unit: '°'
      }).appendTo('position-size-properties');
      
      createPropertyBlock('dropdown', 'positioning', {
        label: 'Positioning',
        options: ['Absolute', 'Relative']
      }).appendTo('position-size-properties');
      
      // Style properties
      createPropertyBlock('text', 'fill', {
        label: 'Fill'
      }).appendTo('style-properties');
      
      createPropertyBlock('text', 'stroke', {
        label: 'Stroke'
      }).appendTo('style-properties');
      
      createPropertyBlock('number', 'radius', {
        label: 'Radius',
        min: 0,
        max: 100
      }).appendTo('style-properties');
      
      createPropertyBlock('dropdown', 'blend', {
        label: 'Blend',
        options: ['Normal', 'Multiply', 'Screen', 'Overlay']
      }).appendTo('style-properties');
      
      createPropertyBlock('text', 'shadow', {
        label: 'Shadow'
      }).appendTo('style-properties');
      
      // Text properties
      createPropertyBlock('number', 'font-size', {
        label: 'Font Size',
        min: 0,
        max: 200
      }).appendTo('text-properties');
      
      createPropertyBlock('text', 'color', {
        label: 'Color'
      }).appendTo('text-properties');
      
      createPropertyBlock('dropdown', 'alignment', {
        label: 'Alignment',
        options: ['Left', 'Center', 'Right', 'Justify']
      }).appendTo('text-properties');
      
      createPropertyBlock('text', 'line-height', {
        label: 'Line Height'
      }).appendTo('text-properties');
      
      createPropertyBlock('text', 'letter-spacing', {
        label: 'Letter Spacing'
      }).appendTo('text-properties');
      
      console.log('Property blocks created');
    }
    
    // End of Property Block Component System

    // Configure section behaviors
    function initSections() {
      console.log('Initializing sections');
      
      // Find all sections
      document.querySelectorAll('.section-header').forEach(header => {
        // Remove any existing event listeners by cloning and replacing
        const newHeader = header.cloneNode(true);
        header.parentNode.replaceChild(newHeader, header);
        
        const section = newHeader.parentElement;
        const wrapper = section.querySelector('.section-content-wrapper');
        const arrow = newHeader.querySelector('.section-arrow');
        
        // Set initial state - closed
        wrapper.style.height = '0';
        
        // Add click handler for the new header
        newHeader.addEventListener('click', () => {
          if (section.classList.contains('expanded')) {
            // Collapse section
            wrapper.style.height = wrapper.scrollHeight + 'px';
            wrapper.offsetHeight; // Force reflow
            wrapper.style.height = '0';
            section.classList.remove('expanded');
            arrow.classList.remove('expanded');
          } else {
            // Expand section
            section.classList.add('expanded');
            arrow.classList.add('expanded');
            wrapper.style.height = 'auto';
            const targetHeight = wrapper.scrollHeight;
            wrapper.style.height = '0';
            wrapper.offsetHeight; // Force reflow
            wrapper.style.height = targetHeight + 'px';
          }
        });
      });
      
      // Expand the first section by default
      const firstSection = document.querySelector('.section');
      if (firstSection) {
        const header = firstSection.querySelector('.section-header');
        if (header) {
          header.click();
        }
      }
    }

    function interpretRotation(rotation) {
      // Ensure rotation is between 0 and 360
      rotation = (rotation % 360 + 360) % 360;
      return rotation;
    }

    /**
     * Behavior for dropdown selection
     */
    class DropdownBehavior extends EditBehavior {
      constructor(options = {}) {
        super(options);
        this.dropdownOptions = options.options || [];
        console.log('DropdownBehavior created with options:', options);
      }
      
      initialize(block) {
        super.initialize(block);
        console.log('DropdownBehavior initialized for block:', block.propertyName);
      }
      
      renderValue(value, container) {
        console.log('DropdownBehavior renderValue:', value);
        // Clear existing content
        container.innerHTML = '';
        
        // Display the value
        container.textContent = value || this.dropdownOptions[0] || 'Select...';
      }
      
      renderEditableValue() {
        console.log('DropdownBehavior renderEditableValue');
        const valueContainer = this.block.element.querySelector('.property-value');
        if (!valueContainer) {
          console.error('Property value container not found');
          return;
        }
        
        // Clear existing content
        valueContainer.innerHTML = '';
        
        // Create select
        const select = document.createElement('select');
        
        // Add options
        this.dropdownOptions.forEach(option => {
          const optionElement = document.createElement('option');
          optionElement.value = option.value || option;
          optionElement.textContent = option.label || option;
          select.appendChild(optionElement);
        });
        
        // Set current value
        const currentValue = this.block.getValue();
        console.log('Current dropdown value:', currentValue);
        if (currentValue) {
          select.value = currentValue;
        }
        
        // Handle selection
        select.addEventListener('change', () => {
          const newValue = select.value;
          console.log('Dropdown value changed to:', newValue);
          this.block.setValue(newValue);
          this.block.element.classList.add('manually-edited');
        });
        
        // Add to container and focus
        valueContainer.appendChild(select);
        select.focus();
      }
    }

    /**
     * Behavior for text input
     */
    class TextBehavior extends EditBehavior {
      constructor(options = {}) {
        super(options);
        this.multiline = options.multiline || false;
      }
      
      renderValue(value, container) {
        // Clear existing content
        container.innerHTML = '';
        
        // Display the value
        container.textContent = value || '';
      }
      
      renderEditableValue() {
        const valueContainer = this.block.element.querySelector('.property-value');
        if (!valueContainer) return;
        
        // Clear existing content
        valueContainer.innerHTML = '';
        
        // Create input based on multiline option
        const input = this.multiline ? 
          document.createElement('textarea') : 
          document.createElement('input');
        
        if (!this.multiline) {
          input.type = 'text';
        }
        
        // Set current value
        input.value = this.block.getValue() || '';
        
        // Handle input
        input.addEventListener('input', () => {
          const newValue = input.value;
          this.block.setValue(newValue);
          this.block.element.classList.add('manually-edited');
        });
        
        // Add to container and focus
        valueContainer.appendChild(input);
        input.focus();
        input.select();
      }
    }

    /**
     * Factory function to create property blocks
     */
    function createPropertyBlock(type, propertyName, options = {}) {
      console.log(`Creating ${type} property block for ${propertyName}`);
      
      const block = new PropertyBlock(propertyName, options);
      
      // Add common behaviors
      block.addBehavior(new ResetButtonBehavior());
      
      // Add type-specific behaviors
      switch (type) {
        case 'number':
          console.log(`Adding NumberInputBehavior to ${propertyName}`);
          block.addBehavior(new NumberInputBehavior(options));
          break;
        case 'dropdown':
          console.log(`Adding DropdownBehavior to ${propertyName} with options:`, options.options);
          block.addBehavior(new DropdownBehavior(options));
          break;
        case 'text':
          console.log(`Adding TextBehavior to ${propertyName}`);
          block.addBehavior(new TextBehavior(options));
          break;
        default:
          console.warn(`Unknown property block type: ${type}, using TextBehavior as fallback`);
          block.addBehavior(new TextBehavior(options));
      }
      
      console.log(`Property block ${propertyName} created successfully`);
      return block;
    }
  </script>
  
  <!-- Initialization script -->
  <script>
    // Single initialization function that handles everything
    function initializeUI() {
      console.log('Initializing UI');
      
      // 1. Initialize property blocks
      if (typeof initPropertyBlocks === 'function') {
        initPropertyBlocks();
      } else {
        console.error('initPropertyBlocks function not defined');
      }
      
      // 2. Initialize section behaviors
      if (typeof initSections === 'function') {
        initSections();
      } else {
        console.error('initSections function not defined');
      }
      
      // 3. Notify plugin that UI is ready
      parent.postMessage({ pluginMessage: { type: 'ui-ready' } }, '*');
      console.log('UI initialization complete');
    }
    
    // Initialize on DOMContentLoaded (safer approach)
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeUI);
    } else {
      // DOM already loaded, run immediately
      initializeUI();
    }
  </script>
</body>
</html> 