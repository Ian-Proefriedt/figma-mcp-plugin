<!DOCTYPE html>
<html>
<head>
  <style>
    /* Core variables */
    :root {
      --background-color: #2c2c2c;
      --text-color: #e0e0e0;
      --border-color: #444444;
      --section-hover: #3e3e3e;
      --property-background: rgba(255, 255, 255, 0.06);
      --property-text: #cccccc;
      --property-label: #888888;
      --accent-color: #4C8BFF;
      --grid-gap: 8px;
    }

    /* Base elements */
    body {
      background-color: var(--background-color);
      color: var(--text-color);
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      margin: 0;
      padding: 0;
      font-size: 11px;
    }

    /* Layout containers */
    .plugin-container {
      padding: 0 12px;
      position: relative;
    }

    /* Sections */
    .section {
      margin: 0 -12px;
      border-bottom: 1px solid var(--border-color);
      display: block;
    }

    .section.hidden {
      display: none;
    }

    .section-header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 12px;
      cursor: pointer;
      user-select: none;
    }

    .section-header:hover {
      background-color: var(--section-hover);
    }

    .section-header h3 {
      font-size: 11px;
      margin: 0;
      font-weight: 500;
    }

    .section-arrow {
      width: 12px;
      height: 12px;
      display: flex;
      align-items: center;
      justify-content: center;
      transition: transform 0.3s cubic-bezier(0.4, 0, 0.2, 1);
      font-size: 8px;
      transform: rotate(-90deg);
    }

    .section-arrow.expanded {
      transform: rotate(0deg);
    }

    .section-content-wrapper {
      height: 0;
      overflow: hidden;
      transition: height 0.3s cubic-bezier(0.4, 0, 0.2, 1);
    }

    .section-content {
      padding: 8px 12px;
      max-width: 300px;
    }

    /* Property grid */
    .properties-grid {
      display: flex;
      flex-wrap: wrap;
      gap: var(--grid-gap);
      max-width: 100%;
    }

    /* Property blocks */
    .property-block {
      background-color: var(--property-background);
      border-radius: 4px;
      padding: 4px 8px;
      display: flex;
      justify-content: space-between;
      align-items: center;
      height: 28px;
      min-width: fit-content;
      max-width: 100%;
      flex: 0 1 auto;
      position: relative;
      box-sizing: border-box;
      border: 1px solid transparent;
      transition: border-color 0.2s ease;
    }

    .property-block:hover {
      border-color: rgba(255, 255, 255, 0.1);
    }

    .property-label {
      color: var(--property-label);
      font-size: 11px;
      white-space: nowrap;
      margin-right: 12px;
    }

    .property-value {
      color: var(--property-text);
      font-weight: 500;
      font-size: 11px;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
      display: flex;
      align-items: center;
      flex: 1;
      flex-direction: row;
    }

    /* Property block states */
    .property-block[data-state="default"] {
      background-color: var(--property-background);
      border-color: transparent;
    }

    .property-block[data-state="editing"] {
      border-color: var(--accent-color);
      background-color: var(--section-hover);
    }

    .property-block[data-state="modified"] {
      border-color: var(--accent-color);
    }

    .property-block[data-state="locked"] {
      opacity: 0.7;
      pointer-events: none;
    }

    /* Input controls */
    .property-block[data-state="editing"] input,
    .property-block[data-state="editing"] select {
      background: var(--section-hover);
      border: 1px solid var(--border-color);
      border-radius: 2px;
      color: var(--text-color);
      font-size: 11px;
      padding: 2px 4px;
      min-width: 40px;
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
      height: 20px;
    }

    .property-block[data-state="editing"] input[type="number"] {
      width: 50px;
      text-align: right;
    }

    .property-block[data-state="editing"] select {
      min-width: 80px;
      height: 24px;
    }

    /* Remove spinner arrows from number inputs */
    input[type=number]::-webkit-inner-spin-button,
    input[type=number]::-webkit-outer-spin-button {
      -webkit-appearance: none;
      margin: 0;
    }
    
    input[type=number] {
      -moz-appearance: textfield;
      appearance: textfield;
    }

    /* Standard number input styling */
    .property-block input[type=number] {
      width: auto;
      min-width: 30px;
      padding: 2px 4px;
      text-align: center;
      background-color: var(--background-color);
      border: 1px solid var(--accent-color);
      border-radius: 4px;
      color: var(--text-color);
      outline: none;
      box-shadow: 0 0 0 2px rgba(76, 139, 255, 0.2);
      font-size: 11px;
      font-weight: 500;
      font-family: -apple-system, BlinkMacSystemFont, 'Inter', sans-serif;
    }

    /* Labels for multi-input fields */
    .property-position-value:first-child::before { content: "X: "; }
    .property-position-value:last-child::before { content: "Y: "; }
    .property-size-value:first-child::before { content: "X: "; }
    .property-size-value:last-child::before { content: "Y: "; }
    .property-constraints-value:first-child::before { content: "H: "; }
    .property-constraints-value:last-child::before { content: "V: "; }
    .property-sizing-value:first-child::before { content: "H: "; }
    .property-sizing-value:last-child::before { content: "V: "; }
    .property-padding-value::before { content: attr(data-label); }

    /* Common label styling for pseudo-elements */
    .property-position-value::before,
    .property-size-value::before,
    .property-constraints-value::before,
    .property-sizing-value::before,
    .property-padding-value::before {
      color: var(--property-label);
      font-size: 11px;
      font-weight: normal;
    }

    /* Color display */
    .property-color {
      display: flex;
      align-items: center;
      gap: 4px;
      min-width: 0;
      flex: 1;
    }

    .property-color-preview {
      flex-shrink: 0;
      width: 12px;
      height: 12px;
      border-radius: 2px;
      border: 1px solid var(--border-color);
    }

    .property-color-value {
      flex: 1;
      min-width: 0;
      overflow: hidden;
      text-overflow: ellipsis;
      white-space: nowrap;
    }

    .property-opacity-value {
      flex-shrink: 0;
      color: var(--property-text);
      opacity: 0.8;
      margin-left: 4px;
      padding-left: 4px;
      border-left: 1px solid var(--border-color);
    }

    /* Stroke property */
    .property-stroke {
      display: flex;
      align-items: center;
      gap: 4px;
    }

    .property-stroke span {
      flex-shrink: 0;
      min-width: 16px;
      text-align: right;
    }

    .property-stroke-weight {
      flex-shrink: 0;
      color: var(--property-text);
      opacity: 0.8;
      margin-left: 4px;
      padding-left: 4px;
      border-left: 1px solid var(--border-color);
    }

    /* Radius property */
    .property-radius {
      display: flex;
      align-items: center;
    }

    .property-radius-value {
      min-width: 16px;
      text-align: right;
    }

    /* Selection title */
    .selection-title {
      padding: 12px;
      border-bottom: 1px solid var(--border-color);
      margin: 0 -12px;
      display: flex;
      flex-direction: column;
      justify-content: center;
      min-height: fit-content;
    }

    .selection-name {
      font-size: 13px;
      font-weight: 500;
      color: var(--text-color);
      margin: 0;
      padding: 0;
      line-height: 1.4;
    }

    .selection-type {
      font-size: 11px;
      color: var(--property-label);
      margin: 4px 0 0 0;
      padding: 0;
      line-height: 1.2;
    }

    /* Status indicator */
    .status-indicator {
      position: absolute;
      top: 12px;
      right: 12px;
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background-color: #4CAF50;
      opacity: 0.8;
    }

    .status-indicator.error {
      background-color: #f44336;
    }

    .status-indicator.warning {
      background-color: #ff9800;
    }

    /* Utility states */
    .status-bar, .layer-tree, .raw-data {
      display: none;
    }

    /* Buttons */
    .property-block .edit-button,
    .property-block .reset-button {
      display: none;
      background: none;
      border: none;
      color: var(--text-color);
      width: 16px;
      height: 16px;
      border-radius: 2px;
      margin-left: 4px;
      cursor: pointer;
      opacity: 0.7;
    }

    .property-block .edit-button:hover,
    .property-block .reset-button:hover {
      opacity: 1;
      background-color: var(--section-hover);
    }

    .property-block .edit-button::before {
      content: "✎";
      font-size: 10px;
    }

    .property-block .reset-button::before {
      content: "↺";
      font-size: 10px;
    }

    .property-block:not(.editing):hover .edit-button {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .property-block.manually-edited .reset-button {
      display: flex;
      align-items: center;
      justify-content: center;
    }

    /* Specific styling for dropdown property blocks */
    .property-block[data-property-type="dropdown"] {
      display: flex !important; /* Force flex display */
      flex-direction: row !important; /* Force horizontal layout */
    }
    
    /* Remove the special styling for blend mode property - treat it like other dropdowns */
    
    .property-block:hover {
      border-color: rgba(255, 255, 255, 0.1);
    }
  </style>
</head>
<body>
  <div class="plugin-container">
    <div class="status-indicator" title="Plugin initialized"></div>
    <div class="selection-title">
      <h2 class="selection-name">No Selection</h2>
      <p class="selection-type">Select an element to view properties</p>
      </div>

    <div class="section">
      <div class="section-header">
        <h3>Layout</h3>
        <div class="section-arrow">▼</div>
      </div>
      <div class="section-content-wrapper">
        <div class="section-content">
          <div class="properties-grid" id="layout-properties">
            <!-- Layout properties will be dynamically generated here -->
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-header">
        <h3>Position & Size</h3>
        <div class="section-arrow">▼</div>
        </div>
      <div class="section-content-wrapper">
        <div class="section-content">
          <div class="properties-grid" id="position-size-properties">
            <!-- Position & Size properties will be dynamically generated here -->
          </div>
        </div>
      </div>
    </div>

    <div class="section">
      <div class="section-header">
        <h3>Styles</h3>
        <div class="section-arrow">▼</div>
      </div>
      <div class="section-content-wrapper">
        <div class="section-content">
          <div class="properties-grid" id="style-properties">
            <!-- Style properties will be dynamically generated here -->
          </div>
        </div>
        </div>
      </div>

    <div class="section">
      <div class="section-header">
        <h3>Text</h3>
        <div class="section-arrow">▼</div>
      </div>
      <div class="section-content-wrapper">
        <div class="section-content">
          <div class="properties-grid" id="text-properties">
            <!-- Text properties will be dynamically generated here -->
          </div>
        </div>
        </div>
      </div>

    <div class="section">
      <div class="section-header">
        <h3>Raw Data</h3>
        <div class="section-arrow">▼</div>
        </div>
      <div class="section-content-wrapper">
        <div class="section-content">
          <pre id="raw-data"></pre>
      </div>
    </div>
  </div>

    <div class="status-bar">
      <div class="status-text">Plugin Status: <span id="plugin-status">Initializing...</span></div>
    </div>
  </div>

  <!-- Load utility scripts -->
  <script>
    // ======================================================
    // GLOBAL INITIALIZATION - These must be defined first 
    // ======================================================
    
    // Centralized logging system - defined first to ensure it's available everywhere
    window.Logger = (function() {
      // Define constants directly rather than as object properties
      const DEBUG = 0;
      const INFO = 1;
      const WARN = 2;
      const ERROR = 3;
      
      // Debug flag for production vs development
      const isDebug = false;
      
      // Current log level
      const currentLevel = isDebug ? DEBUG : INFO;
      
      // Create a resilient logger that doesn't depend on property references
      return {
        // Expose log levels as constants
        LEVELS: {
          DEBUG: DEBUG,
          INFO: INFO,
          WARN: WARN,
          ERROR: ERROR
        },
        
        // Debug flag for production vs development
        DEBUG: isDebug,
        
        // Current log level
        level: currentLevel,
        
        // Prefix for all log messages
        prefix: '[MCP] ',
        
        // Enable/disable specific logging categories
        categories: {
          properties: true,  // Property value logs 
          nodeData: true,    // Raw node data logs
          ui: true           // UI update logs
        },
        
        // Debug logs - detailed information
        debug: function(component, message, data) {
          if (currentLevel <= DEBUG && this.categories[component.toLowerCase()] !== false) {
            console.debug(`${this.prefix}${component}: ${message}`, data || '');
          }
        },
        
        // Info logs - normal operation information
        info: function(component, message, data) {
          if (currentLevel <= INFO) {
            console.info(`${this.prefix}${component}: ${message}`, data || '');
          }
        },
        
        // Warning logs - potentially problematic situations
        warn: function(component, message, data) {
          if (currentLevel <= WARN) {
            console.warn(`${this.prefix}${component}: ${message}`, data || '');
          }
        },
        
        // Error logs - failures that need attention
        error: function(component, message, data) {
          if (currentLevel <= ERROR) {
            console.error(`${this.prefix}${component}: ${message}`, data || '');
          }
        }
      };
    })();
    
    // ======================================================
    // UTILITY FUNCTIONS - Define before they are used
    // ======================================================
    
    // Safe execution wrapper to standardize error handling
    function safeExecute(fn, errorMessage = 'Operation failed', fallback = null) {
      try {
        return fn();
      } catch (error) {
        console.error(`${errorMessage}: ${error.message}`);
        return fallback;
      }
    }
    
    // UI Factory for creating elements with standard patterns
    const UIFactory = {
      // Create an element with common attributes
      createElement(tagName, options = {}) {
        const element = document.createElement(tagName);
        
        if (options.className) element.className = options.className;
        if (options.id) element.id = options.id;
        if (options.textContent) element.textContent = options.textContent;
        
        return element;
      },
      
      // Create a button with standard properties
      createButton(text, onClick) {
        const button = this.createElement('button', { textContent: text });
        if (onClick) button.addEventListener('click', onClick);
        return button;
      }
    };
    
    // Ensure PropertyRegistry is initialized as a global variable
    window.PropertyRegistry = {
      // Layout properties
      'type': {
        type: 'dropdown',
        label: 'Type',
        options: ['Block', 'Flex'],
        section: 'layout',
        priority: 10,
        getValue: (data) => (data.layout && data.layout.autoLayout && data.layout.autoLayout.mode !== undefined) ? "Flex" : "Block",
        render: (el, value) => { el.textContent = value; }
      },
      'direction': {
        type: 'dropdown',
        label: 'Direction',
        options: ['row', 'column'],
        section: 'layout',
        priority: 20,
        getValue: (data) => (data.layout && data.layout.autoLayout && data.layout.autoLayout.mode === "VERTICAL") ? "column" : "row",
        render: (el, value) => { el.textContent = value; }
      },
      'align': {
        type: 'dropdown',
        label: 'Align',
        options: ['flex-start', 'center', 'flex-end', 'space-between'],
        section: 'layout',
        priority: 30,
        getValue: (data) => {
          const align = (data.layout && data.layout.autoLayout && data.layout.autoLayout.counterAxis && data.layout.autoLayout.counterAxis.alignItems) || "MIN";
          return (align === "MIN" ? "flex-start" : 
                  align === "MAX" ? "flex-end" : 
                  align === "CENTER" ? "center" : "flex-start");
        },
        render: (el, value) => { el.textContent = value; }
      },
      'justify': {
        type: 'dropdown',
        label: 'Justify',
        options: ['flex-start', 'center', 'flex-end', 'space-between', 'space-around'],
        section: 'layout',
        priority: 40,
        getValue: (data) => {
          const justify = (data.layout && data.layout.autoLayout && data.layout.autoLayout.primaryAxis && data.layout.autoLayout.primaryAxis.alignItems) || "MIN";
          return (justify === "MIN" ? "flex-start" : 
                 justify === "MAX" ? "flex-end" : 
                 justify === "CENTER" ? "center" : 
                 justify === "SPACE_BETWEEN" ? "space-between" : "flex-start");
        },
        render: (el, value) => { el.textContent = value; }
      },
      'gap': {
        type: 'number',
        label: 'Gap',
        min: 0,
        max: 1000,
        section: 'layout',
        priority: 50,
        getValue: (data) => (data.layout && data.layout.autoLayout && data.layout.autoLayout.spacing && data.layout.autoLayout.spacing.items) || 0,
        render: (el, value) => { el.textContent = value; }
      },
      'overflow': {
        type: 'dropdown',
        label: 'Overflow',
        options: ['visible', 'hidden'],
        section: 'layout',
        priority: 60,
        getValue: (data) => (data.visual && data.visual.clipsContent) ? "hidden" : "visible",
        render: (el, value) => { el.textContent = value; }
      },
      
      // Position & Size properties
      'z-index': {
        type: 'number',
        label: 'Z-Index',
        min: -999,
        max: 999,
        section: 'position-size',
        priority: 10,
        getValue: (data) => data.zIndex || 0,
        render: (el, value) => { el.textContent = value; }
      },
      'positioning': {
        type: 'dropdown',
        label: 'Positioning',
        options: ['Absolute', 'Relative'],
        section: 'position-size',
        priority: 20,
        getValue: (data) => {
          // const isActuallyInAutoLayout = PropertyInterpreter.isActuallyInAutoLayout(data);
          const isInAutoLayout = 
            (data.layout && data.layout.type === 'AUTO') || 
            (data.layout && data.layout.parent && data.layout.parent.type === 'AUTO') ||
            (data.layout && data.layout.parent && data.layout.parent.layoutMode === "HORIZONTAL") ||
            (data.layout && data.layout.parent && data.layout.parent.layoutMode === "VERTICAL");
          const ignoresAutoLayout = (data.layout && data.layout.isIgnoringAutoLayout === true);
          return (isInAutoLayout && !ignoresAutoLayout) ? "Relative" : "Absolute";
        },
        render: (el, value) => { el.textContent = value; }
      },
      'rotation': {
        type: 'number',
        label: 'Rotation',
        min: 0,
        max: 360,
        unit: '°',
        section: 'position-size',
        priority: 30,
        getValue: (data) => {
          const rotation = (data.transform && data.transform.rotation) || 0;
          return Math.round(rotation * (180/Math.PI));
        },
        render: (el, value) => { el.textContent = `${value}°`; }
      },
      
      // Style properties
      'fill': {
        type: 'text',
        label: 'Fill',
        section: 'style',
        priority: 10,
        getValue: (data) => {
          if (!data.visual || !data.visual.fills || data.visual.fills.length === 0) {
            return { preview: null, text: 'None', opacity: 100 };
          }
          
          const fill = data.visual.fills[0];
          if (fill.type !== 'SOLID' || !fill.color) {
            return { preview: null, text: 'Complex', opacity: 100 };
          }
          
          return {
            preview: fill.color,
            text: PropertyInterpreter.rgbToHex(fill.color.r, fill.color.g, fill.color.b),
            opacity: Math.round((fill.opacity || 1) * 100)
          };
        },
        render: (el, value) => {
          const colorPreview = el.querySelector('.property-color-preview');
          const colorValue = el.querySelector('.property-color-value');
          const opacityValue = el.querySelector('.property-opacity-value');
          
          if (value.preview) {
            const color = value.preview;
            const opacity = value.opacity / 100;
            if (colorPreview) {
              colorPreview.style.backgroundColor = `rgba(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)}, ${opacity})`;
            }
          } else if (colorPreview) {
            colorPreview.style.backgroundColor = 'transparent';
          }
          
          if (colorValue) colorValue.textContent = value.text;
          if (opacityValue) opacityValue.textContent = `${value.opacity}%`;
        }
      },
      'stroke': {
        type: 'text',
        label: 'Stroke',
        section: 'style',
        priority: 20,
        getValue: (data) => {
          if (!data.visual || !data.visual.strokes || data.visual.strokes.length === 0) {
            return { preview: null, text: 'None', opacity: 100 };
          }
          
          const stroke = data.visual.strokes[0];
          if (stroke.type !== 'SOLID' || !stroke.color) {
            return { preview: null, text: 'Complex', opacity: 100 };
          }
          
          return {
            preview: stroke.color,
            text: PropertyInterpreter.rgbToHex(stroke.color.r, stroke.color.g, stroke.color.b),
            opacity: Math.round((stroke.opacity || 1) * 100),
            weight: stroke.weight || 1
          };
        },
        render: (el, value) => {
          const colorPreview = el.querySelector('.property-color-preview');
          const colorValue = el.querySelector('.property-color-value');
          
          if (value.preview) {
            const color = value.preview;
            if (colorPreview) {
              colorPreview.style.backgroundColor = `rgb(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)})`;
            }
          } else if (colorPreview) {
            colorPreview.style.backgroundColor = 'transparent';
          }
          
          if (colorValue) colorValue.textContent = value.text;
        }
      },
      'radius': {
        type: 'number',
        label: 'Radius',
        min: 0,
        max: 100,
        section: 'style',
        priority: 30,
        getValue: (data) => (data.visual && data.visual.cornerRadius) || 0,
        render: (el, value) => { el.textContent = value; }
      },
      'blend': {
        type: 'dropdown',
        label: 'Blend',
        options: ['Normal', 'Multiply', 'Screen', 'Overlay'],
        section: 'style',
        priority: 40,
        getValue: (data) => PropertyInterpreter.blendMode((data.visual && data.visual.blendMode) || 'NORMAL'),
        render: (el, value) => { el.textContent = value; }
      },
      'shadow': {
        type: 'text',
        label: 'Shadow', 
        section: 'style',
        priority: 50,
        getValue: (data) => {
          if (!data.visual || !data.visual.shadows || data.visual.shadows.length === 0) {
            return 'None';
          }
          return 'Custom';
        },
        render: (el, value) => { el.textContent = value; }
      },
      
      // Text properties
      'font-size': {
        type: 'number',
        label: 'Font Size',
        min: 0,
        max: 200,
        section: 'text',
        priority: 10,
        getValue: (data) => (data.text && data.text.style && data.text.style.fontSize) || 0,
        render: (el, value) => { el.textContent = value; }
      },
      'color': {
        type: 'text',
        label: 'Color',
        section: 'text',
        priority: 20,
        getValue: (data) => {
          if (!data.text || !data.text.style || !data.text.style.color) {
            return { preview: null, text: 'None' };
          }
          
          const color = data.text.style.color;
          return {
            preview: color,
            text: PropertyInterpreter.rgbToHex(color.r, color.g, color.b)
          };
        },
        render: (el, value) => {
          const colorPreview = el.querySelector('.property-color-preview');
          const colorValue = el.querySelector('.property-color-value');
          
          if (value.preview) {
            const color = value.preview;
            if (colorPreview) {
              colorPreview.style.backgroundColor = `rgb(${Math.round(color.r * 255)}, ${Math.round(color.g * 255)}, ${Math.round(color.b * 255)})`;
            }
          } else if (colorPreview) {
            colorPreview.style.backgroundColor = 'transparent';
          }
          
          if (colorValue) colorValue.textContent = value.text;
        }
      },
      'alignment': {
        type: 'dropdown',
        label: 'Alignment',
        options: ['Left', 'Center', 'Right', 'Justify'],
        section: 'text',
        priority: 30,
        getValue: (data) => {
          const alignment = (data.text && data.text.style && data.text.style.alignment && data.text.style.alignment.horizontal) || 'LEFT';
          return alignment.charAt(0) + alignment.slice(1).toLowerCase();
        },
        render: (el, value) => { el.textContent = value; }
      },
      'line-height': {
        type: 'text',
        label: 'Line Height',
        section: 'text',
        priority: 40,
        getValue: (data) => {
          const lineHeight = data.text && data.text.style && data.text.style.spacing && data.text.style.spacing.line;
          return (lineHeight && lineHeight.value !== undefined) ? lineHeight.value : 'Auto';
        },
        render: (el, value) => { el.textContent = value; }
      },
      'letter-spacing': {
        type: 'text',
        label: 'Letter Spacing',
        section: 'text',
        priority: 50,
        getValue: (data) => {
          const letterSpacing = data.text && data.text.style && data.text.style.spacing && data.text.style.spacing.letter;
          if (!letterSpacing || letterSpacing.value === undefined) return '0';
          
          return letterSpacing.unit === 'PERCENT' 
            ? `${letterSpacing.value}%`
            : letterSpacing.value;
        },
        render: (el, value) => { el.textContent = value; }
      }
    };
    
    // PropertyBlock and Behavior classes - add before other code
    class PropertyBlock {
      constructor(nameOrElement, options = {}) {
        this.behaviors = [];
        this.options = options;
        
        if (typeof nameOrElement === 'string') {
          // Create new property block
          this.propertyName = nameOrElement;
          this.element = this.createBlockElement(nameOrElement, options);
        } else {
          // Use existing element
          this.element = nameOrElement;
          this.propertyName = this.element.dataset.property;
        }
      }
      
      createBlockElement(propertyName, options) {
        const block = document.createElement('div');
        block.className = 'property-block';
        block.dataset.property = propertyName;
        block.dataset.state = 'default';
        
        // Set property type if provided
        if (options.type) {
          block.dataset.propertyType = options.type;
        }
        
        if (options.label) {
          const label = document.createElement('div');
          label.className = 'property-label';
          label.textContent = options.label;
          block.appendChild(label);
        }
        
        const valueContainer = document.createElement('div');
        valueContainer.className = 'property-value';
        
        // Remove special styling for blend mode - treat it like other dropdowns
        
        block.appendChild(valueContainer);
        
        return block;
      }
      
      addBehavior(behavior) {
        this.behaviors.push(behavior);
        behavior.initialize(this);
        return this;
      }
      
      appendTo(containerId) {
        const container = document.getElementById(containerId);
        if (container) {
          container.appendChild(this.element);
        }
        return this;
      }
      
      setValue(value, options = {}) {
        const valueContainer = this.element.querySelector('.property-value');
        if (!valueContainer) return;
        
        this.value = value;
        
        // Store original value if isOriginal flag is set
        if (options.isOriginal) {
          valueContainer.dataset.originalContent = String(value);
        }
        
        // Notify behaviors
        this.behaviors.forEach(behavior => {
          if (behavior.onValueChange) {
            behavior.onValueChange(value, valueContainer);
          }
        });
        
        return this;
      }
      
      getValue() {
        const valueContainer = this.element.querySelector('.property-value');
        return this.value !== undefined ? this.value : (valueContainer && valueContainer.textContent && valueContainer.textContent.trim());
      }
      
      setState(state) {
        this.element.dataset.state = state;
        
        // Notify behaviors
        this.behaviors.forEach(behavior => {
          if (behavior.onStateChange) {
            behavior.onStateChange(state);
          }
        });
        
        return this;
      }
      
      getState() {
        return this.element.dataset.state;
      }
    }
    
    /**
     * Base behavior class for property blocks
     */
    class Behavior {
      constructor() {
        this.block = null;
      }
      
      initialize(block) {
        this.block = block;
      }
      
      renderValue(value, container) {
        container.textContent = value;
      }
      
      onValueChange(value, container) {
        this.renderValue(value, container);
      }
      
      onStateChange(state) {
        // Handle state change
      }
    }
    
    /**
     * Base class for behaviors that handle editing
     */
    class EditBehavior extends Behavior {
      constructor(options = {}) {
        super();
        this.options = options;
        this.isEditing = false;
      }
      
      initialize(block) {
        super.initialize(block);
        
        // Add click handler to start editing
        this.block.element.addEventListener('click', (e) => {
          if (this.block.getState() !== 'locked') {
            this.startEditing();
          }
        });
      }
      
      startEditing() {
        if (this.isEditing) return;
        
        this.isEditing = true;
        this.block.setState('editing');
        this.renderEditableValue();
        
        // Add click outside handler to stop editing
        document.addEventListener('click', this.handleClickOutside = (e) => {
          if (!this.block.element.contains(e.target)) {
            this.stopEditing();
          }
        });
      }
      
      stopEditing() {
        if (!this.isEditing) return;
        
        this.isEditing = false;
        this.block.setState(this.block.element.classList.contains('manually-edited') ? 'modified' : 'default');
        
        // Remove click outside handler
        document.removeEventListener('click', this.handleClickOutside);
      }
      
      renderEditableValue() {
        // To be implemented by subclasses
      }
    }
    
    /**
     * Behavior for number inputs
     */
    class NumberInputBehavior extends EditBehavior {
      constructor(options = {}) {
        super(options);
        this.min = options.min !== undefined ? options.min : -Infinity;
        this.max = options.max !== undefined ? options.max : Infinity;
        this.step = options.step || 1;
        this.unit = options.unit || '';
      }
      
      renderValue(value, container) {
        // Clear existing content
        container.innerHTML = '';
        
        // Format value with unit if provided
        const formattedValue = `${value}${this.unit}`;
        container.textContent = formattedValue;
      }
      
      renderEditableValue() {
        const valueContainer = this.block.element.querySelector('.property-value');
        if (!valueContainer) return;
        
        // Clear existing content
        valueContainer.innerHTML = '';
        
        // Create input
        const input = document.createElement('input');
        input.type = 'number';
        input.min = this.min;
        input.max = this.max;
        input.step = this.step;
        
        // Remove unit for editing
        const currentValue = this.block.getValue();
        const numericValue = parseFloat(currentValue);
        input.value = isNaN(numericValue) ? 0 : numericValue;
        
        // Handle input
        input.addEventListener('input', () => {
          const newValue = parseFloat(input.value);
          if (!isNaN(newValue)) {
            // Use setValue to update the value with the unit
            this.block.setValue(newValue);
            this.block.element.classList.add('manually-edited');
          }
        });
        
        // Add to container and focus
        valueContainer.appendChild(input);
        input.focus();
        input.select();
      }
    }
    
    /**
     * Behavior for reset button
     */
    class ResetButtonBehavior extends Behavior {
      constructor() {
        super();
      }
      
      initialize(block) {
        super.initialize(block);
        
        // Find or create reset button
        let resetButton = block.element.querySelector('.reset-button');
        if (!resetButton) {
          resetButton = document.createElement('button');
          resetButton.className = 'reset-button';
          resetButton.title = 'Reset to original value';
          block.element.appendChild(resetButton);
        }
        
        // Add click handler
        resetButton.addEventListener('click', (e) => {
          e.stopPropagation();
          this.resetToOriginal();
        });
      }
      
      resetToOriginal() {
        const valueContainer = this.block.element.querySelector('.property-value');
        if (!valueContainer || !valueContainer.dataset.originalContent) return;
        
        // Reset value to original
        this.block.setValue(valueContainer.dataset.originalContent);
        this.block.element.classList.remove('manually-edited');
        this.block.setState('default');
      }
    }

    // Centralized Property Interpreter Utility
    const PropertyInterpreter = {
      /**
       * Determines the layout type based on Figma node properties
       */
      layoutType: function(node) {
      if (!node) return "None";
      
        if (node.layout && node.layout.autoLayout && node.layout.autoLayout.mode) {
        return "Flex";
      }
      
      if (node.type === "FRAME") {
        return "Block";
      }
        
      if (node.type === "GROUP") {
        return "Flex";
      }
      
      return "None";
      },
      
      /**
       * Interprets Figma's layout mode into CSS flex direction
       */
      direction: function(node) {
        const mode = node.layout && node.layout.autoLayout && node.layout.autoLayout.mode;
        return mode === "VERTICAL" ? "column" : "row";
      },
      
      /**
       * Interprets Figma's counter axis alignment into CSS align-items
       */
      alignItems: function(node) {
        const align = node.layout && node.layout.autoLayout && node.layout.autoLayout.counterAxis && node.layout.autoLayout.counterAxis.alignItems;
        
        switch (align) {
          case "MIN": return "flex-start";
          case "MAX": return "flex-end";
          case "CENTER": return "center";
          case "SPACE_BETWEEN": return "space-between";
          default: return "flex-start";
        }
      },
      
      /**
       * Interprets Figma's primary axis alignment into CSS justify-content
       */
      justifyContent: function(node) {
        const justify = node.layout && node.layout.autoLayout && node.layout.autoLayout.primaryAxis && node.layout.autoLayout.primaryAxis.alignItems;
        
        switch (justify) {
          case "MIN": return "flex-start";
          case "MAX": return "flex-end";
          case "CENTER": return "center";
          case "SPACE_BETWEEN": return "space-between";
          case "SPACE_AROUND": return "space-around";
          default: return "flex-start";
        }
      },
      
      /**
       * Interprets Figma's padding values into CSS padding
       */
      padding: function(node) {
        const padding = node.layout && node.layout.autoLayout && node.layout.autoLayout.padding;
        
        return {
          top: padding && padding.top || 0,
          right: padding && padding.right || 0,
          bottom: padding && padding.bottom || 0,
          left: padding && padding.left || 0
        };
      },
      
      /**
       * Interprets Figma's spacing values into CSS gap
       */
      gap: function(node) {
        return node.layout && node.layout.autoLayout && node.layout.autoLayout.spacing && node.layout.autoLayout.spacing.items || 0;
      },
      
      /**
       * Interprets Figma's blend mode
       */
      blendMode: function(mode) {
        if (!mode) return 'Normal';
        
        const blendModes = {
          'PASS_THROUGH': 'Pass Through',
          'NORMAL': 'Normal',
          'DARKEN': 'Darken',
          'MULTIPLY': 'Multiply',
          'LINEAR_BURN': 'Linear Burn',
          'COLOR_BURN': 'Color Burn',
          'LIGHTEN': 'Lighten',
          'SCREEN': 'Screen',
          'LINEAR_DODGE': 'Linear Dodge',
          'COLOR_DODGE': 'Color Dodge',
          'OVERLAY': 'Overlay',
          'SOFT_LIGHT': 'Soft Light',
          'HARD_LIGHT': 'Hard Light',
          'DIFFERENCE': 'Difference',
          'EXCLUSION': 'Exclusion',
          'HUE': 'Hue',
          'SATURATION': 'Saturation',
          'COLOR': 'Color',
          'LUMINOSITY': 'Luminosity'
        };
        
        return blendModes[mode] || mode;
      },
      
      /**
       * Converts RGB to HEX color
       */
      rgbToHex: function(r, g, b) {
      const toHex = (n) => {
        const hex = Math.round(n * 255).toString(16);
        return hex.length === 1 ? '0' + hex : hex;
      };
      return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
      },
      
      /**
       * Determines if a node actually should be in auto layout despite being marked absolute
       */
      isActuallyInAutoLayout: function(data) {
        if (data.type !== "TEXT") return false;

        const layoutMode = data.layout && data.layout.parent && data.layout.parent.layoutMode;
        const positioning = data.layout && data.layout.positioning;
        const constraints = (data.layout && data.layout.constraints) || {};
        const hasNeutralConstraints = (
          constraints.horizontal === "MIN" &&
          constraints.vertical === "MIN"
        );

        const isMarkedAbsolute = positioning === "ABSOLUTE";
        const isInsideAutoLayout = layoutMode === "HORIZONTAL" || layoutMode === "VERTICAL";
        const isAutoPositioning = positioning === "AUTO";

        if (isMarkedAbsolute && isInsideAutoLayout && hasNeutralConstraints) {
          return true;
        }

        if (isAutoPositioning) {
          return true;
        }

        return false;
      }
    };

    // Function to render property group
    function renderPropertyGroup(container, title, properties) {
      const group = document.createElement('div');
      group.className = 'property-group';
      
      const titleEl = document.createElement('div');
      titleEl.className = 'property-group-title';
      titleEl.textContent = title;
      group.appendChild(titleEl);

      Object.entries(properties).forEach(([key, value]) => {
        const item = document.createElement('div');
        item.className = 'property-item';
        
        const name = document.createElement('span');
        name.className = 'property-name';
        name.textContent = key;
        
        const val = document.createElement('span');
        val.className = 'property-value';
        val.textContent = formatValue(value);
        
        item.appendChild(name);
        item.appendChild(val);
        group.appendChild(item);
      });

      container.appendChild(group);
    }

    // Helper function to format values
    function formatValue(value) {
      if (value === null) return 'null';
      if (value === undefined) return 'undefined';
      if (typeof value === 'object') {
        return JSON.stringify(value, null, 2);
      }
      return String(value);
    }
    
    function displayRawData(data) {
      if (!data) return;
      
      const rawDataDisplay = document.getElementById('raw-data');
      if (!rawDataDisplay) return;
      
      rawDataDisplay.innerHTML = '';

      // Group and display properties
      if (data.id && data.name && data.type) {
        renderPropertyGroup(rawDataDisplay, 'Basic Info', {
          id: data.id,
          name: data.name,
          type: data.type,
          visible: data.visible
        });
      }

      if (data.position) {
        renderPropertyGroup(rawDataDisplay, 'Position', data.position);
      }

      if (data.size) {
        renderPropertyGroup(rawDataDisplay, 'Size', data.size);
      }

      if (data.transform) {
        renderPropertyGroup(rawDataDisplay, 'Transform', data.transform);
      }

      if (data.layout) {
        renderPropertyGroup(rawDataDisplay, 'Layout', data.layout);
      }

      if (data.visual) {
        renderPropertyGroup(rawDataDisplay, 'Visual', data.visual);
      }

      // Type-specific properties
      if (data.text) {
        renderPropertyGroup(rawDataDisplay, 'Text Properties', data.text);
      }

      if (data.component) {
        renderPropertyGroup(rawDataDisplay, 'Component Properties', data.component);
      }

      if (data.section) {
        renderPropertyGroup(rawDataDisplay, 'Section Properties', data.section);
      }

      if (data.group) {
        renderPropertyGroup(rawDataDisplay, 'Group Properties', data.group);
      }

      if (data.vector) {
        renderPropertyGroup(rawDataDisplay, 'Vector Properties', data.vector);
      }
    }

    const pluginStatus = document.getElementById('plugin-status');
    const rawDataDisplay = document.getElementById('raw-data');

    // Centralized state management
    const AppState = {
      currentSelection: null,
      
      // Status management
      updateStatus: function(message) {
        const statusEl = document.getElementById('plugin-status');
        if (statusEl) statusEl.textContent = message;
      },
      
      // Selection management
      setSelection: function(data) {
        this.currentSelection = data;
        this.updateUI();
      },
      
      // UI update orchestration
      updateUI: function() {
        if (!this.currentSelection) return;
        
        updateSelectionInfo(this.currentSelection);
        updateSectionVisibility(this.currentSelection);
        updateVisibilityByType(this.currentSelection);
        PropertyHandler.updateAllProperties(this.currentSelection);
        updatePropertyStates(this.currentSelection);
        
        // For debugging
        displayRawData(this.currentSelection);
      },
      
      // Find a property block by property name
      findPropertyBlock: function(name) {
        const element = document.querySelector(`[data-property="${name}"]`);
        return element ? new PropertyBlock(element) : null;
      },
      
      // Update a property value
      updatePropertyValue: function(name, value, isOriginal = true) {
        const block = this.findPropertyBlock(name);
        if (block) {
          block.setValue(value, { isOriginal });
          return true;
        }
        return false;
      },
      
      // Set a property state
      setPropertyState: function(name, state) {
        const block = this.findPropertyBlock(name);
        if (block) {
          block.setState(state);
        return true;
      }
      return false;
    }
    };
    
    // Handler for selection change messages
    function handleSelectionChange(data) {
      if (!data) return;
      
      window.Logger.debug('Selection', 'Selection change data', data);
      window.Logger.debug('Selection', 'Selection data type', typeof data);
      
      // If data is an array or has items, use the first item
      if (data.items && Array.isArray(data.items) && data.items.length > 0) {
        window.Logger.debug('Selection', 'Using first item from selection array');
        data = data.items[0];
      }
      
      // Store and update UI
      AppState.setSelection(data);
    }
    
    // Update selection title display
    function updateSelectionInfo(data) {
      if (!data) return;

      const nameEl = document.querySelector('.selection-name');
      const typeEl = document.querySelector('.selection-type');
      
      if (nameEl) nameEl.textContent = data.name || 'Unnamed';
      
      if (typeEl) {
        const typeText = data.type 
          ? data.type.charAt(0) + data.type.slice(1).toLowerCase() 
          : 'Unknown';
        typeEl.textContent = typeText;
      }
    }
    
    // Update status display
    function updateStatus(message) {
      AppState.updateStatus(message);
    }

    // Update the window.onmessage handler
    window.onmessage = (event) => {
      // Validate the message
      const msg = event.data.pluginMessage;
      if (!msg || !msg.type) {
        window.Logger.warn('Messaging', 'Invalid message received', event.data);
        return;
      }
      
      // Handle different message types
      switch (msg.type) {
        case 'selection-change':
        case 'selection':
          window.Logger.debug('Messaging', 'Selection changed', msg.data && msg.data.id);
          handleSelectionChange(msg.data);
          break;
          
        case 'raw-node-data':
          window.Logger.debug('Messaging', 'Raw node data received', msg.data && msg.data.id);
          handleRawNodeData(msg.data);
          break;
          
        case 'plugin-status':
          window.Logger.info('Messaging', `Status: ${msg.message || 'Unknown'}`);
          updateStatus(msg.message || 'Unknown status');
          break;
          
        case 'init':
          window.Logger.info('Messaging', 'Plugin initialized');
          break;
          
        default:
          window.Logger.warn('Messaging', 'Unknown message type', msg.type);
      }
    };

    // Consolidated section visibility management
    function updateSectionVisibility(data) {
      if (!data) return;

      // Map of section headers to visibility conditions
      const sectionVisibility = {
        'Layout': true,
        'Position & Size': true,
        'Styles': true,
        'Text': data.type === 'TEXT',
        'Raw Data': false // Always hidden
      };
      
      // Update visibility for each section
      document.querySelectorAll('.section').forEach(section => {
        const header = section.querySelector('h3');
        if (!header) return;
        
        const headerText = header.textContent;
        const isVisible = sectionVisibility[headerText] !== undefined 
          ? sectionVisibility[headerText] 
          : true;
        
        section.classList.toggle('hidden', !isVisible);
      });
    }

    // Notify plugin that UI is ready
    parent.postMessage({ pluginMessage: { type: 'ready' } }, '*');

    // Function to initialize property blocks from registry
    function initPropertyBlocks() {
      window.Logger.info('Init', 'Initializing property blocks with registry system');
      
      // Clear existing property containers
      document.querySelectorAll('.properties-grid').forEach(grid => {
        grid.innerHTML = '';
      });
      
      // Layout section properties
      const layoutProperties = document.getElementById('layout-properties');
      const positionSizeProperties = document.getElementById('position-size-properties');
      const styleProperties = document.getElementById('style-properties');
      const textProperties = document.getElementById('text-properties');
      
      if (!layoutProperties || !positionSizeProperties || !styleProperties || !textProperties) {
        window.Logger.error('Init', 'Could not find property containers', {
          layoutProperties,
          positionSizeProperties,
          styleProperties,
          textProperties
        });
        return;
      }
      
      window.Logger.debug('Init', 'Found property containers, creating blocks from registry');
      
      // Group properties by section
      const sections = {
        'layout': [],
        'position-size': [],
        'style': [],
        'text': []
      };
      
      // Sort properties into sections
      Object.entries(window.PropertyRegistry).forEach(([propName, definition]) => {
        if (definition.section && sections[definition.section]) {
          sections[definition.section].push({
            name: propName,
            ...definition,
            priority: definition.priority || 100
          });
        }
      });
      
      // Create blocks for each section, sorted by priority
      Object.entries(sections).forEach(([sectionName, props]) => {
        // Sort by priority
        props.sort((a, b) => a.priority - b.priority);
        
        // Create blocks
        props.forEach(prop => {
          createPropertyBlock(prop.type, prop.name, {
            label: prop.label,
            options: prop.options,
            min: prop.min,
            max: prop.max,
            step: prop.step,
            unit: prop.unit
          }).appendTo(`${sectionName}-properties`);
        });
      });
      
      window.Logger.info('Init', 'Property blocks created successfully', { 
        blockCount: Object.values(sections).reduce((total, items) => total + items.length, 0) 
      });
    }
    
    // End of Property Block Component System

    // Configure section behaviors
    function initSections() {
      window.Logger.info('Init', 'Initializing section behaviors');
      
      // Set initial state for all sections - closed
      document.querySelectorAll('.section-content-wrapper').forEach(wrapper => {
        wrapper.style.height = '0';
      });
      
      // Use event delegation instead of individual listeners
      const container = document.querySelector('.plugin-container');
      if (container) {
        container.addEventListener('click', (event) => {
          // Find if a section header or its child was clicked
          const header = event.target.closest('.section-header');
          if (!header) return;
          
          const section = header.parentElement;
        const wrapper = section.querySelector('.section-content-wrapper');
          const arrow = header.querySelector('.section-arrow');
        
          if (!wrapper || !arrow) return;
        
          if (section.classList.contains('expanded')) {
            // Collapse section
            wrapper.style.height = wrapper.scrollHeight + 'px';
            wrapper.offsetHeight; // Force reflow
            wrapper.style.height = '0';
            section.classList.remove('expanded');
            arrow.classList.remove('expanded');
          } else {
            // Expand section
            section.classList.add('expanded');
            arrow.classList.add('expanded');
            wrapper.style.height = 'auto';
            const targetHeight = wrapper.scrollHeight;
            wrapper.style.height = '0';
            wrapper.offsetHeight; // Force reflow
            wrapper.style.height = targetHeight + 'px';
          }
        });
      }
      
      // Expand the first section by default
      const firstSection = document.querySelector('.section');
      if (firstSection) {
        const header = firstSection.querySelector('.section-header');
        if (header) {
          // Trigger a click event instead of calling click()
          const clickEvent = new MouseEvent('click', {
            bubbles: true,
            cancelable: true
          });
          header.dispatchEvent(clickEvent);
        }
      }
    }

    function interpretRotation(rotation) {
      // Ensure rotation is between 0 and 360
      rotation = (rotation % 360 + 360) % 360;
      return rotation;
    }

    /**
     * Behavior for dropdown selection
     */
    class DropdownBehavior extends EditBehavior {
      constructor(options = {}) {
        super(options);
        this.dropdownOptions = options.options || [];
      }
      
      renderValue(value, container) {
        // Clear existing content
        container.innerHTML = '';
        
        // Display the value
        container.textContent = value || this.dropdownOptions[0] || 'Select...';
        
        // Add dropdown indicator (arrow)
        const valueContainer = container.closest('.property-value');
        if (!valueContainer) {
          window.Logger.error('Dropdown', 'Property value container not found for dropdown');
          return;
        }
      }
      
      renderEditableValue() {
        const valueContainer = this.block.element.querySelector('.property-value');
        if (!valueContainer) {
          window.Logger.error('Property value container not found for dropdown');
          return;
        }
        
        // Clear existing content
        valueContainer.innerHTML = '';
        
        // Create select
        const select = document.createElement('select');
        
        // Add options
        this.dropdownOptions.forEach(option => {
          const optionElement = document.createElement('option');
          optionElement.value = option.value || option;
          optionElement.textContent = option.label || option;
          select.appendChild(optionElement);
        });
        
        // Set current value
        const currentValue = this.block.getValue();
        if (currentValue) {
          select.value = currentValue;
        }
        
        // Handle selection
        select.addEventListener('change', () => {
          const newValue = select.value;
          this.block.setValue(newValue);
          this.block.element.classList.add('manually-edited');
          
          // Auto-close dropdown after selection
          setTimeout(() => this.stopEditing(), 0);
        });
        
        // Add to container and focus
        valueContainer.appendChild(select);
        select.focus();
      }
    }

    /**
     * Behavior for text input
     */
    class TextBehavior extends EditBehavior {
      constructor(options = {}) {
        super(options);
        this.multiline = options.multiline || false;
      }
      
      renderValue(value, container) {
        // Clear existing content
        container.innerHTML = '';
        
        // Display the value
        container.textContent = value || '';
      }
      
      renderEditableValue() {
        const valueContainer = this.block.element.querySelector('.property-value');
        if (!valueContainer) return;
        
        // Clear existing content
        valueContainer.innerHTML = '';
        
        // Create input based on multiline option
        const input = this.multiline ? 
          document.createElement('textarea') : 
          document.createElement('input');
        
        if (!this.multiline) {
          input.type = 'text';
        }
        
        // Set current value
        input.value = this.block.getValue() || '';
        
        // Handle input
        input.addEventListener('input', () => {
          const newValue = input.value;
          this.block.setValue(newValue);
          this.block.element.classList.add('manually-edited');
        });
        
        // Add to container and focus
        valueContainer.appendChild(input);
        input.focus();
        input.select();
      }
    }

    /**
     * Factory function to create property blocks with improved validation and error handling
     * @param {string} type - Type of property block (number, dropdown, text)
     * @param {string} propertyName - Name of the property
     * @param {Object} options - Options for the property block
     * @returns {PropertyBlock} - The created property block
     */
    function createPropertyBlock(type, propertyName, options = {}) {
      if (!propertyName) {
        window.Logger.error('PropertyBlock', 'Property name is required for property block creation');
        return null;
      }
      
      // Validate options based on type
      switch (type) {
        case 'number':
          options.min = options.min !== undefined ? options.min : -Infinity;
          options.max = options.max !== undefined ? options.max : Infinity;
          options.step = options.step || 1;
          break;
          
        case 'dropdown':
          if (!Array.isArray(options.options) || options.options.length === 0) {
            window.Logger.warn('PropertyBlock', `Dropdown property ${propertyName} created without valid options`);
            options.options = ['Default'];
          }
          break;
          
        case 'text':
          options.multiline = options.multiline || false;
          break;
          
        default:
          window.Logger.warn('PropertyBlock', `Unknown property block type: ${type}, defaulting to text`);
          type = 'text';
      }
      
      // Add type to options
      options.type = type;
      
      const block = new PropertyBlock(propertyName, options);
      
      // Add common behaviors
      block.addBehavior(new ResetButtonBehavior());
      
      // Add type-specific behaviors
      switch (type) {
        case 'number':
          block.addBehavior(new NumberInputBehavior(options));
          break;
        case 'dropdown':
          block.addBehavior(new DropdownBehavior(options));
          break;
        case 'text':
          block.addBehavior(new TextBehavior(options));
          break;
      }
      
      return block;
    }

    // Add a data-driven property update system
    const PropertyHandler = {
      // Update a single property by name
      updateProperty: function(propertyName, data) {
        const definition = window.PropertyRegistry[propertyName];
        if (!definition) {
          window.Logger.warn('Properties', `No definition found for property: ${propertyName}`);
          return false;
        }
        
        const valueEl = document.querySelector(`[data-property="${propertyName}"] .property-value`);
        if (!valueEl) {
          window.Logger.debug('Properties', `Element not found for property: ${propertyName}`);
          return false;
        }
        
        try {
          const value = definition.getValue(data);
          definition.render(valueEl, value);
          
          window.Logger.debug('Properties', `Updated ${propertyName}`, {
            property: propertyName,
            value: typeof value === 'object' ? '[complex]' : value
          });
          
          // Also update AppState for backward compatibility
          if (typeof value === 'object') {
            // For complex properties like fill, we don't update AppState
          } else {
            AppState.updatePropertyValue(propertyName, value);
          }
          
          return true;
        } catch (error) {
          window.Logger.error('Properties', `Error updating property ${propertyName}`, error);
          return false;
        }
      },
      
      // Update multiple properties at once
      updateProperties: function(propertyNames, data) {
        window.Logger.debug('Properties', `Updating multiple properties: ${propertyNames.join(', ')}`);
        propertyNames.forEach(name => this.updateProperty(name, data));
      },
      
      // Update all properties
      updateAllProperties: function(data) {
        window.Logger.info('Properties', 'Updating all properties', { 
          dataType: data && data.type, 
          properties: Object.keys(window.PropertyRegistry).length 
        });
        
        window.Logger.debug('Properties', 'PropertyHandler.updateAllProperties - Data', data);
        window.Logger.debug('Properties', 'PropertyHandler.updateAllProperties - PropertyRegistry', Object.keys(window.PropertyRegistry));
        
        // Generate debug information before updating
        this.debugPropertyValues(data);
        
        // Create a collection of all property values for a summary
        const propertyValues = {};
        
        Object.keys(window.PropertyRegistry).forEach(name => {
          try {
            const definition = window.PropertyRegistry[name];
            // Store the interpreted value for summary
            propertyValues[name] = definition.getValue(data);
          } catch (error) {
            propertyValues[name] = `ERROR: ${error.message}`;
          }
          
          // Update the UI with the value
          this.updateProperty(name, data);
        });
        
        // Log a scannable summary of all properties
        this.logPropertySummary(propertyValues, data);
      },
      
      // Log a scannable summary table of all properties
      logPropertySummary: function(propertyValues, data) {
        // Make sure there's data and debug level
        if (!data || !window.Logger || !window.Logger.LEVELS || window.Logger.level > window.Logger.LEVELS.DEBUG) return;
        
        // Group properties by category
        const layout = {};
        const position = {};
        const style = {};
        const text = {};
        
        // Sort properties into categories
        Object.entries(propertyValues).forEach(([name, value]) => {
          const definition = window.PropertyRegistry[name];
          if (!definition) return;
          
          // Skip nullish/empty values
          if (value === undefined || value === null || value === '') return;
          
          // Format value for logging
          const logValue = typeof value === 'object' ? '[object]' : String(value);
          
          switch (definition.section) {
            case 'layout':
              layout[name] = logValue;
              break;
            case 'position-size':
              position[name] = logValue;
              break;
            case 'style':
              style[name] = logValue;
              break;
            case 'text':
              text[name] = logValue;
              break;
          }
        });
        
        // Log properties by section
        window.Logger.debug('Properties', `Node ${data.name} (${data.type}) summary:`);
        
        if (Object.keys(layout).length > 0) {
          window.Logger.debug('Properties', 'Layout', layout);
        }
        
        if (Object.keys(position).length > 0) {
          window.Logger.debug('Properties', 'Position & Size', position);
        }
        
        if (Object.keys(style).length > 0) {
          window.Logger.debug('Properties', 'Style', style);
        }
        
        if (Object.keys(text).length > 0) {
          window.Logger.debug('Properties', 'Text', text);
        }
      },
      
      // Debug property values - generate a detailed comparison of raw vs interpreted values
      debugPropertyValues: function(data) {
        if (!data) return;
        
        // Only log in DEBUG level
        if (!window.Logger || !window.Logger.LEVELS || window.Logger.level > window.Logger.LEVELS.DEBUG) return;
        
        console.group(`=== Property Values for Node: ${data.name} (${data.id}) ===`);
        
        // For each property in the registry
        Object.entries(window.PropertyRegistry).forEach(([propName, definition]) => {
          try {
            // Get the raw property path from the definition
            let rawValue = '[No path info]';
            let rawValueString = '';
            
            // Get raw value based on property name and typical paths
            if (propName === 'type' || propName === 'direction') {
              rawValue = data.layout && data.layout.autoLayout && data.layout.autoLayout.mode;
              rawValueString = `data.layout.autoLayout.mode = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'align') {
              rawValue = data.layout && data.layout.autoLayout && data.layout.autoLayout.counterAxis && data.layout.autoLayout.counterAxis.alignItems;
              rawValueString = `data.layout.autoLayout.counterAxis.alignItems = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'justify') {
              rawValue = data.layout && data.layout.autoLayout && data.layout.autoLayout.primaryAxis && data.layout.autoLayout.primaryAxis.alignItems;
              rawValueString = `data.layout.autoLayout.primaryAxis.alignItems = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'gap') {
              rawValue = data.layout && data.layout.autoLayout && data.layout.autoLayout.spacing && data.layout.autoLayout.spacing.items;
              rawValueString = `data.layout.autoLayout.spacing.items = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'overflow') {
              rawValue = data.clipsContent;
              rawValueString = `data.clipsContent = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'z-index') {
              rawValue = data.zIndex;
              rawValueString = `data.zIndex = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'positioning') {
              rawValue = {
                layout: data.layout && data.layout.type,
                parent: data.layout && data.layout.parent && data.layout.parent.type,
                parentLayoutMode: data.layout && data.layout.parent && data.layout.parent.layoutMode,
                positioning: data.layout && data.layout.positioning,
                ignoresAutoLayout: data.layout && data.layout.isIgnoringAutoLayout
              };
              rawValueString = `data.layout.[multiple] = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'rotation') {
              rawValue = data.rotation;
              rawValueString = `data.rotation = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'fill') {
              rawValue = data.visual && data.visual.fills;
              rawValueString = `data.visual.fills = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'stroke') {
              rawValue = data.visual && data.visual.strokes;
              rawValueString = `data.visual.strokes = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'radius') {
              rawValue = data.visual && data.visual.cornerRadius;
              rawValueString = `data.visual.cornerRadius = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'blend') {
              rawValue = data.visual && data.visual.blendMode;
              rawValueString = `data.visual.blendMode = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'shadow') {
              rawValue = data.visual && data.visual.shadows;
              rawValueString = `data.visual.shadows = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'font-size') {
              rawValue = data.text && data.text.style && data.text.style.fontSize;
              rawValueString = `data.text.style.fontSize = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'color') {
              rawValue = data.text && data.text.style && data.text.style.color;
              rawValueString = `data.text.style.color = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'alignment') {
              rawValue = data.text && data.text.style && data.text.style.alignment && data.text.style.alignment.horizontal;
              rawValueString = `data.text.style.alignment.horizontal = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'line-height') {
              rawValue = data.text && data.text.style && data.text.style.spacing && data.text.style.spacing.line;
              rawValueString = `data.text.style.spacing.line = ${JSON.stringify(rawValue)}`;
            } else if (propName === 'letter-spacing') {
              rawValue = data.text && data.text.style && data.text.style.spacing && data.text.style.spacing.letter;
              rawValueString = `data.text.style.spacing.letter = ${JSON.stringify(rawValue)}`;
            }
            
            // Get the interpreted value
            let interpretedValue;
            try {
              interpretedValue = definition.getValue ? definition.getValue(data) : '[No getValue function]';
            } catch (error) {
              interpretedValue = `ERROR: ${error.message}`;
              window.Logger.error('Properties', `Error getting interpreted value for ${propName}`, error);
            }
            
            console.log(`Property: ${propName}`);
            console.log(`  Raw: ${rawValueString}`);
            console.log(`  Interpreted: ${JSON.stringify(interpretedValue)}`);
            
          } catch (error) {
            window.Logger.error('Properties', `Error in debugPropertyValues for ${propName}`, error);
          }
        });
        
        console.groupEnd();
      },
      
      // Update properties by category
      updateCategory: function(category, data) {
        // Find all properties in the given category
        const propertiesToUpdate = Object.entries(PropertyRegistry)
          .filter(([_, def]) => def.section === category)
          .map(([name, _]) => name);
          
        window.Logger.debug('Properties', `Updating ${category} properties`, { count: propertiesToUpdate.length });
        this.updateProperties(propertiesToUpdate, data);
      }
    };
    
    // Update handlers for node data
    function handleRawNodeData(data) {
      if (!data) {
        window.Logger.warn('NodeData', 'Received null or undefined node data');
        return;
      }
      
      // IMPORTANT: Log the full data structure to debug issues
      window.Logger.debug('NodeData', 'Full data structure received', data);
      window.Logger.debug('NodeData', 'Data type', typeof data);
      window.Logger.debug('NodeData', 'Data properties', Object.keys(data));
      
      // Log detailed raw data for debugging
      if (window.Logger.level <= window.Logger.LEVELS.DEBUG) {
        window.Logger.debug('NodeData', `Raw Node Data: ${data.name} (${data.id})`);
        window.Logger.debug('NodeData', 'Basic Info', { id: data.id, name: data.name, type: data.type });
        
        if (data.layout) window.Logger.debug('NodeData', 'Layout', data.layout);
        if (data.visual) window.Logger.debug('NodeData', 'Visual', data.visual);
        if (data.text) window.Logger.debug('NodeData', 'Text', data.text);
        if (data.position) window.Logger.debug('NodeData', 'Position', data.position);
        if (data.size) window.Logger.debug('NodeData', 'Size', data.size);
      }
      
      window.Logger.info('NodeData', 'Processing node data', { 
        id: data.id, 
        type: data.type,
        name: data.name 
      });
      
      // Update UI with raw node data
      updateSelectionInfo(data);
      updateSectionVisibility(data);
      updateVisibilityByType(data);
      
      // Use the data-driven PropertyHandler to update all properties consistently
      PropertyHandler.updateAllProperties(data);
      
      // Set property states based on auto layout
      updatePropertyStates(data);
    }
    
    // Update property states (locked/unlocked) based on context
    function updatePropertyStates(data) {
      if (!data) return;
      
      try {
        const isActuallyInAutoLayout = PropertyInterpreter.isActuallyInAutoLayout(data);
        const isInAutoLayout = 
          (data.layout && data.layout.type === 'AUTO') || 
          (data.layout && data.layout.parent && data.layout.parent.type === 'AUTO') ||
          (data.layout && data.layout.parent && data.layout.parent.layoutMode === "HORIZONTAL") ||
          (data.layout && data.layout.parent && data.layout.parent.layoutMode === "VERTICAL") ||
          isActuallyInAutoLayout;
        const ignoresAutoLayout = (data.layout && data.layout.isIgnoringAutoLayout === true) && !isActuallyInAutoLayout;
        
        window.Logger.debug('Properties', 'Updating property states', {
          isInAutoLayout,
          ignoresAutoLayout
        });
        
        // Lock/unlock position and constraints based on auto layout
        if (isInAutoLayout && !ignoresAutoLayout) {
          AppState.setPropertyState('position', 'locked');
          AppState.setPropertyState('constraints', 'locked');
        } else {
          AppState.setPropertyState('position', 'default');
          AppState.setPropertyState('constraints', 'default');
        }
      } catch (error) {
        window.Logger.error('Properties', 'Error updating property states', error);
      }
    }

    // The PropertyHandler system replaces these individual update functions
    // Layout, Text and Visual properties are now handled by PropertyHandler.updateProperty
    function updateVisibilityByType(data) {
      if (!data) {
        window.Logger.warn('UI', 'Cannot update visibility: no data provided');
        return;
      }

      // Show/hide property blocks based on element type
      const visibilityMap = {
        'fill': ['FRAME', 'RECTANGLE', 'ELLIPSE', 'POLYGON', 'STAR', 'TEXT'],
        'stroke': ['FRAME', 'RECTANGLE', 'ELLIPSE', 'POLYGON', 'STAR'],
        'radius': ['FRAME', 'RECTANGLE'],
        'opacity': true, // Always show
        'blend': true,   // Always show
        'shadow': ['FRAME', 'RECTANGLE', 'ELLIPSE', 'POLYGON', 'STAR', 'TEXT']
      };
      
      window.Logger.debug('UI', 'Updating property visibility', { elementType: data.type });
      
      // Update visibility for property blocks
      Object.entries(visibilityMap).forEach(([property, types]) => {
        const block = document.querySelector(`[data-property="${property}"]`);
        if (!block) return;
        
        const isVisible = types === true || 
          (Array.isArray(types) && types.includes(data.type));
        
        block.style.display = isVisible ? 'block' : 'none';
      });
    }

    function findPropertyBlock(propertyName) {
      return document.querySelector(`[data-property="${propertyName}"]`);
    }

    function updatePropertyValue(propertyName, value) {
      const block = findPropertyBlock(propertyName);
      if (!block) return false;
      
      const valueContainer = block.querySelector('.property-value');
      if (!valueContainer) return false;
      
      window.Logger.debug('UI', `Updated property value: ${propertyName} = ${value}`);
      valueContainer.textContent = value;
      
      return true;
    }

    function setPropertyState(propertyName, state) {
      const block = findPropertyBlock(propertyName);
      if (!block) return false;
      
      // Remove existing state classes
      block.classList.remove('editing', 'modified', 'locked');
      
      // Add new state if specified
      if (state) {
        block.classList.add(state);
      }
      
      return true;
    }

    // Add utility functions for showing/hiding elements with animation
  </script>
  
  <!-- Initialization script -->
  <script>
    // Single initialization function that handles everything
    function initializeUI() {
      // First check if Logger exists before using it
      if (!window.Logger) {
        console.error('Logger is not defined, cannot initialize properly');
        return;
      }
      
      window.Logger.info('Init', 'Starting UI initialization');
      
      // Check if PropertyRegistry exists before initializing property blocks
      if (typeof window.PropertyRegistry === 'undefined' || Object.keys(window.PropertyRegistry).length === 0) {
        window.Logger.error('Init', 'PropertyRegistry is not properly defined, cannot initialize property blocks');
        return;
      }
      
      // 1. Initialize property blocks
      safeExecute(
        () => { 
      if (typeof initPropertyBlocks === 'function') {
        initPropertyBlocks();
            return true;
      }
          window.Logger.error('Init', 'initPropertyBlocks function not defined');
          return false;
        },
        'Failed to initialize property blocks'
      );
      
      // 2. Initialize section behaviors
      safeExecute(
        () => {
      if (typeof initSections === 'function') {
        initSections();
            return true;
      }
          window.Logger.error('Init', 'initSections function not defined');
          return false;
        },
        'Failed to initialize sections'
      );
      
      // 3. Notify plugin that UI is ready
      parent.postMessage({ pluginMessage: { type: 'ui-ready' } }, '*');
      window.Logger.info('Init', 'UI initialization complete');
    }
    
    // Initialize on DOMContentLoaded (safer approach)
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initializeUI);
    } else {
      // Add a small delay to ensure all scripts are loaded and processed
      setTimeout(initializeUI, 0);
    }
  </script>
</body>
</html> 